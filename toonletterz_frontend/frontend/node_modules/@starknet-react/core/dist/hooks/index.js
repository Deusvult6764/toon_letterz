// src/hooks/useAccount.ts
import { useCallback as useCallback3, useEffect as useEffect2, useState as useState2 } from "react";

// src/context/account.tsx
import React, { useContext } from "react";
import { jsx } from "react/jsx-runtime";
var AccountContext = React.createContext(
  void 0
);
function useStarknetAccount() {
  const account = useContext(AccountContext);
  return { account };
}

// src/context/starknet.tsx
import { goerli as goerli2, mainnet as mainnet2, sepolia as sepolia2 } from "@starknet-react/chains";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import {
  createContext,
  useCallback,
  useContext as useContext2,
  useEffect,
  useRef,
  useState
} from "react";
import { constants } from "starknet";

// src/connectors/injected.ts
import { goerli, mainnet, sepolia } from "@starknet-react/chains";

// src/connectors/base.ts
import EventEmitter from "eventemitter3";

// src/context/starknet.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var defaultQueryClient = new QueryClient();
var StarknetContext = createContext(void 0);
function useStarknet() {
  const state = useContext2(StarknetContext);
  if (!state) {
    throw new Error(
      "useStarknet must be used within a StarknetProvider or StarknetConfig"
    );
  }
  return state;
}

// src/hooks/useConnect.ts
import { useCallback as useCallback2 } from "react";

// src/query.ts
import {
  useMutation as useMutation_,
  useQuery as useQuery_
} from "@tanstack/react-query";
function useQuery(args) {
  const base = useQuery_(args);
  return {
    data: base.data,
    error: base.error,
    status: base.status,
    isSuccess: base.isSuccess,
    isError: base.isError,
    isPending: base.isPending,
    fetchStatus: base.fetchStatus,
    isFetching: base.isFetching,
    isLoading: base.isLoading,
    refetch: base.refetch
  };
}
function useMutation(args) {
  const base = useMutation_(args);
  return {
    data: base.data,
    error: base.error,
    reset: base.reset,
    isError: base.isError,
    isIdle: base.isIdle,
    isPending: base.isPending,
    isSuccess: base.isSuccess,
    isPaused: base.isPaused,
    mutate: base.mutate,
    mutateAsync: base.mutateAsync,
    status: base.status,
    variables: base.variables
  };
}

// src/hooks/useConnect.ts
function useConnect(props = {}) {
  const { connector, connectors, connect: connect_, chain } = useStarknet();
  const { mutate, mutateAsync, variables, ...result } = useMutation({
    mutationKey: [{ entity: "connect", chainId: chain.name }],
    mutationFn: connect_,
    ...props
  });
  const connect = useCallback2(
    (args) => mutate(args ?? { connector }),
    [mutate, connector]
  );
  const connectAsync = useCallback2(
    (args) => mutateAsync(args ?? { connector }),
    [mutateAsync, connector]
  );
  return {
    connector,
    connectors,
    pendingConnector: variables?.connector,
    connect,
    connectAsync,
    variables,
    ...result
  };
}

// src/hooks/useAccount.ts
function useAccount({
  onConnect,
  onDisconnect
} = {}) {
  const { account: connectedAccount } = useStarknetAccount();
  const { connectors } = useConnect();
  const [state, setState] = useState2({
    status: "disconnected"
  });
  const refreshState = useCallback3(async () => {
    if (!connectedAccount) {
      if (!state.isDisconnected && onDisconnect !== void 0) {
        onDisconnect();
      }
      return setState({
        status: "disconnected",
        isDisconnected: true,
        isConnected: false,
        isConnecting: false,
        isReconnecting: false
      });
    }
    for (const connector of connectors) {
      if (!connector.available())
        continue;
      let connAccount;
      try {
        connAccount = await connector.account();
      } catch {
      }
      if (connAccount && connAccount?.address === connectedAccount.address) {
        if (state.isDisconnected && onConnect !== void 0) {
          onConnect({ address: connectedAccount.address, connector });
        }
        return setState({
          connector,
          chainId: await connector.chainId(),
          account: connectedAccount,
          address: connectedAccount.address,
          status: "connected",
          isConnected: true,
          isConnecting: false,
          isDisconnected: false,
          isReconnecting: false
        });
      }
    }
    setState({
      connector: void 0,
      chainId: void 0,
      account: connectedAccount,
      address: connectedAccount.address,
      status: "connected",
      isConnected: true,
      isConnecting: false,
      isDisconnected: false,
      isReconnecting: false
    });
  }, [
    setState,
    connectedAccount,
    connectors,
    onConnect,
    onDisconnect,
    state.isDisconnected
  ]);
  useEffect2(() => {
    refreshState();
  }, [refreshState]);
  return state;
}

// src/hooks/useBalance.ts
import { useMemo as useMemo2 } from "react";
import {
  BlockTag as BlockTag2,
  CallData,
  num,
  shortString,
  uint256
} from "starknet";
import { z } from "zod";

// src/hooks/useContract.ts
import { useMemo } from "react";
import { Contract } from "starknet";
function useContract({
  abi,
  address,
  provider: providedProvider
}) {
  const { provider: currentProvider } = useStarknet();
  const contract = useMemo(() => {
    const provider = providedProvider ? providedProvider : currentProvider;
    if (abi && address && provider) {
      return new Contract(abi, address, provider);
    }
    return void 0;
  }, [abi, address, providedProvider, currentProvider]);
  return { contract };
}

// src/hooks/useInvalidateOnBlock.ts
import { useQueryClient } from "@tanstack/react-query";
import { useEffect as useEffect3, useState as useState3 } from "react";

// src/hooks/useBlockNumber.ts
import { BlockTag } from "starknet";
function useBlockNumber({
  blockIdentifier = BlockTag.latest,
  ...props
} = {}) {
  const { provider } = useStarknet();
  return useQuery({
    queryKey: queryKey({ blockIdentifier }),
    queryFn: queryFn({ provider, blockIdentifier }),
    ...props
  });
}
function queryKey({ blockIdentifier }) {
  return [{ entity: "blockNumber", blockIdentifier }];
}
function queryFn({
  provider,
  blockIdentifier
}) {
  return async function() {
    const block = await provider.getBlock(blockIdentifier);
    return block.block_number;
  };
}

// src/hooks/useInvalidateOnBlock.ts
function useInvalidateOnBlock({
  enabled = true,
  queryKey: queryKey10
}) {
  const queryClient = useQueryClient();
  const [prevBlockNumber, setPrevBlockNumber] = useState3();
  const { data: blockNumber } = useBlockNumber({
    enabled
  });
  useEffect3(() => {
    if (!prevBlockNumber) {
      return setPrevBlockNumber(blockNumber);
    }
    if (blockNumber !== prevBlockNumber) {
      queryClient.invalidateQueries({ queryKey: queryKey10 }, { cancelRefetch: false });
      return setPrevBlockNumber(blockNumber);
    }
  }, [blockNumber, prevBlockNumber]);
}

// src/hooks/useNetwork.ts
function useNetwork() {
  const { chain, chains } = useStarknet();
  return { chain, chains };
}

// src/hooks/useBalance.ts
var DEFAULT_FETCH_INTERVAL = 5e3;
function useBalance({
  token,
  address,
  blockIdentifier = BlockTag2.latest,
  refetchInterval: refetchInterval_,
  watch = false,
  enabled: enabled_ = true,
  ...props
}) {
  const { chain } = useNetwork();
  const { contract } = useContract({
    abi: balanceABIFragment,
    address: token ?? chain.nativeCurrency.address
  });
  const queryKey_ = useMemo2(
    () => queryKey2({ chain, contract, token, address, blockIdentifier }),
    [chain, contract, token, address, blockIdentifier]
  );
  const enabled = useMemo2(
    () => Boolean(enabled_ && contract && address),
    [enabled_, contract, address]
  );
  const refetchInterval = refetchInterval_ ?? (blockIdentifier === BlockTag2.pending && watch ? DEFAULT_FETCH_INTERVAL : void 0);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    enabled,
    queryKey: queryKey_,
    queryFn: queryFn2({ chain, contract, token, address, blockIdentifier }),
    refetchInterval,
    ...props
  });
}
function queryKey2({
  chain,
  contract,
  token,
  address,
  blockIdentifier
}) {
  return [
    {
      entity: "balance",
      chainId: chain?.name,
      contract,
      token,
      address,
      blockIdentifier
    }
  ];
}
function queryFn2({
  chain,
  token,
  address,
  contract,
  blockIdentifier
}) {
  return async function() {
    if (!address)
      throw new Error("address is required");
    if (!contract)
      throw new Error("contract is required");
    const callArgs = { blockIdentifier };
    let symbolPromise = Promise.resolve(chain.nativeCurrency.symbol);
    if (token) {
      symbolPromise = contract.call("symbol", [], callArgs).then((result) => {
        const s = symbolSchema.parse(result).symbol;
        return shortString.decodeShortString(num.toHex(s));
      });
    }
    let decimalsPromise = Promise.resolve(chain.nativeCurrency.decimals);
    if (token) {
      decimalsPromise = contract.call("decimals", [], callArgs).then((result) => {
        return Number(decimalsSchema.parse(result).decimals);
      });
    }
    const balanceOfPromise = contract.call("balanceOf", CallData.compile({ address }), callArgs).then((result) => {
      return uint256.uint256ToBN(balanceSchema.parse(result).balance);
    });
    const [balanceOf, decimals, symbol] = await Promise.all([
      balanceOfPromise,
      decimalsPromise,
      symbolPromise
    ]);
    const formatted = formatUnits(balanceOf, decimals);
    return {
      value: balanceOf,
      decimals,
      symbol,
      formatted
    };
  };
}
var uint256Schema = z.object({
  low: z.bigint(),
  high: z.bigint()
});
var balanceSchema = z.object({
  balance: uint256Schema
});
var decimalsSchema = z.object({
  decimals: z.bigint()
});
var symbolSchema = z.object({
  symbol: z.bigint()
});
var balanceABIFragment = [
  {
    members: [
      {
        name: "low",
        offset: 0,
        type: "felt"
      },
      {
        name: "high",
        offset: 1,
        type: "felt"
      }
    ],
    name: "Uint256",
    size: 2,
    type: "struct"
  },
  {
    name: "balanceOf",
    type: "function",
    inputs: [
      {
        name: "account",
        type: "felt"
      }
    ],
    outputs: [
      {
        name: "balance",
        type: "Uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "symbol",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "decimals",
        type: "felt"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// src/hooks/useBlock.ts
import {
  BlockTag as BlockTag3
} from "starknet";
function useBlock({
  blockIdentifier = BlockTag3.latest,
  ...props
} = {}) {
  const { provider } = useStarknet();
  return useQuery({
    queryKey: queryKey3({ blockIdentifier }),
    queryFn: queryFn3({ provider, blockIdentifier }),
    ...props
  });
}
function queryKey3({ blockIdentifier }) {
  return [{ entity: "block", blockIdentifier }];
}
function queryFn3({
  provider,
  blockIdentifier
}) {
  return async function() {
    return await provider.getBlock(blockIdentifier);
  };
}

// src/hooks/useContractFactory.ts
import { useMemo as useMemo3 } from "react";
import { ContractFactory } from "starknet";
function useContractFactory({
  compiledContract,
  classHash,
  abi
}) {
  const { account } = useAccount();
  const contractFactory = useMemo3(() => {
    if (compiledContract && account && classHash) {
      return new ContractFactory({
        compiledContract,
        classHash,
        account,
        abi
      });
    }
    return void 0;
  }, [compiledContract, classHash, account, abi]);
  return { contractFactory };
}

// src/hooks/useContractRead.ts
import { useMemo as useMemo4 } from "react";
import {
  BlockTag as BlockTag4
} from "starknet";
var DEFAULT_FETCH_INTERVAL2 = 5e3;
function useContractRead({
  abi,
  address,
  functionName,
  args,
  blockIdentifier = BlockTag4.latest,
  parseArgs,
  parseResult,
  refetchInterval: refetchInterval_,
  watch = false,
  enabled: enabled_ = true,
  ...props
}) {
  const { chain } = useNetwork();
  const { contract } = useContract({ abi, address });
  const queryKey_ = useMemo4(
    () => queryKey4({ chain, contract, functionName, args, blockIdentifier }),
    [chain, contract, functionName, args, blockIdentifier]
  );
  const enabled = useMemo4(
    () => Boolean(enabled_ && contract && functionName && args),
    [enabled_, contract, functionName, args]
  );
  const refetchInterval = refetchInterval_ ?? (blockIdentifier === BlockTag4.pending && watch ? DEFAULT_FETCH_INTERVAL2 : void 0);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    enabled,
    queryKey: queryKey_,
    queryFn: queryFn4({
      contract,
      functionName,
      args,
      blockIdentifier,
      parseArgs,
      parseResult
    }),
    refetchInterval,
    ...props
  });
}
function queryKey4({
  chain,
  contract,
  functionName,
  args,
  blockIdentifier
}) {
  return [
    {
      entity: "readContract",
      chainId: chain?.name,
      contract: contract?.address,
      functionName,
      args,
      blockIdentifier
    }
  ];
}
function queryFn4({
  contract,
  functionName,
  args,
  blockIdentifier,
  parseArgs,
  parseResult
}) {
  return async function() {
    if (!contract)
      throw new Error("contract is required");
    if (contract.functions[functionName] === void 0) {
      throw new Error(`function ${functionName} not found in contract`);
    }
    return contract.call(functionName, args, {
      parseRequest: parseArgs,
      parseResponse: parseResult,
      blockIdentifier
    });
  };
}

// src/hooks/useContractWrite.ts
import { useCallback as useCallback4 } from "react";
function useContractWrite({
  calls,
  abis,
  options,
  ...props
}) {
  const { account } = useAccount();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey({ account, calls, abis, options }),
    mutationFn: mutationFn({ account }),
    ...props
  });
  const write = useCallback4(
    (args) => {
      return mutate({
        ...args ?? {
          calls,
          abis,
          options
        }
      });
    },
    [mutate, calls, abis, options]
  );
  const writeAsync = useCallback4(
    (args) => {
      return mutateAsync({
        ...args ?? {
          calls,
          abis,
          options
        }
      });
    },
    [mutateAsync, calls, abis, options]
  );
  return {
    write,
    writeAsync,
    ...result
  };
}
function mutationKey({
  account,
  calls,
  abis,
  options
}) {
  return [{ entity: "contractWrite", account, calls, abis, options }];
}
function mutationFn({
  account
}) {
  return async function({ calls, abis, options }) {
    if (!account)
      throw new Error("account is required");
    if (!calls || calls.length === 0)
      throw new Error("calls are required");
    return await account?.execute(calls, abis, options);
  };
}

// src/hooks/useExplorer.ts
function useExplorer() {
  const { explorer, chain } = useStarknet();
  if (!explorer)
    throw Error("Explorer is undefined. Try adding it to StarknetConfig.");
  const explorerInstance = explorer(chain);
  if (!explorerInstance)
    throw Error("Explorer Instance is undefined");
  return explorerInstance;
}

// src/hooks/useDeployAccount.ts
function useDeployAccount({
  classHash,
  constructorCalldata,
  addressSalt,
  contractAddress,
  options,
  ...props
}) {
  const { account } = useAccount();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey2({
      account,
      classHash,
      constructorCalldata,
      addressSalt,
      contractAddress,
      options
    }),
    mutationFn: mutationFn2({
      account,
      classHash,
      constructorCalldata,
      addressSalt,
      contractAddress,
      options
    }),
    ...props
  });
  return {
    deployAccount: mutate,
    deployAccountAsync: mutateAsync,
    ...result
  };
}
function mutationKey2(props) {
  return [{ entity: "deployAccount", ...props }];
}
function mutationFn2({
  account,
  classHash,
  constructorCalldata,
  addressSalt,
  contractAddress,
  options
}) {
  return async function() {
    if (!account)
      throw new Error("account is required");
    if (!classHash)
      throw new Error("classHash is required");
    return await account.deployAccount(
      { classHash, constructorCalldata, addressSalt, contractAddress },
      options
    );
  };
}

// src/hooks/useDisconnect.ts
function useDisconnect(props = {}) {
  const { disconnect, chain } = useStarknet();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: [{ entity: "disconnect", chainId: chain.name }],
    mutationFn: disconnect,
    ...props
  });
  return {
    disconnect: mutate,
    disconnectAsync: mutateAsync,
    ...result
  };
}

// src/hooks/useProvider.ts
function useProvider() {
  const { provider } = useStarknet();
  return { provider };
}

// src/hooks/useSign.ts
import { useCallback as useCallback5 } from "react";
function useSignTypedData({
  domain,
  types,
  message,
  primaryType,
  ...props
}) {
  const { account } = useAccount();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey3({ domain, types, message, primaryType }),
    mutationFn: mutateFn({ account }),
    ...props
  });
  const signTypedData = useCallback5(
    (args) => mutate(
      args ?? {
        domain,
        types,
        message,
        primaryType
      }
    ),
    [mutate, domain, types, message, primaryType]
  );
  const signTypedDataAsync = useCallback5(
    (args) => mutateAsync(
      args ?? {
        domain,
        types,
        message,
        primaryType
      }
    ),
    [mutateAsync, domain, types, message, primaryType]
  );
  return {
    signTypedData,
    signTypedDataAsync,
    ...result
  };
}
function mutationKey3({
  domain,
  types,
  message,
  primaryType
}) {
  return [
    {
      entity: "signTypedData",
      domain,
      types,
      message,
      primaryType
    }
  ];
}
function mutateFn({ account }) {
  return function({
    domain,
    types,
    message,
    primaryType
  }) {
    if (!account)
      throw new Error("account is required");
    if (!domain)
      throw new Error("domain is required");
    if (!types)
      throw new Error("types is required");
    if (!message)
      throw new Error("message is required");
    if (!primaryType)
      throw new Error("primaryType is required");
    return account.signMessage({ domain, types, message, primaryType });
  };
}

// src/hooks/useStarkAddress.ts
import { useMemo as useMemo5 } from "react";
import { CallData as CallData2, Provider, starknetId } from "starknet";
function useStarkAddress({
  name,
  contract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  const enabled = useMemo5(() => Boolean(enabled_ && name), [enabled_, name]);
  return useQuery({
    queryKey: queryKey5({ name, contract, network: chain.network }),
    queryFn: queryFn5({ name, contract, provider, network: chain.network }),
    enabled,
    ...props
  });
}
function queryKey5({
  name,
  contract,
  network
}) {
  return [{ entity: "addressFromStarkName", name, contract, network }];
}
function queryFn5({
  name,
  contract,
  provider,
  network
}) {
  return async function() {
    if (!name)
      throw new Error("name is required");
    const namingContract = contract ?? StarknetIdNamingContract[network];
    const p = new Provider(provider);
    const encodedDomain = encodeDomain(name);
    const result = await p.callContract({
      contractAddress: namingContract,
      entrypoint: "domain_to_address",
      calldata: CallData2.compile({ domain: encodedDomain, hint: [] })
    });
    if (BigInt(result.result[0]) === BigInt(0))
      throw new Error("Address not found");
    return result.result[0];
  };
}
var StarknetIdNamingContract = {
  goerli: "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",
  sepolia: "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474",
  mainnet: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678"
};
var encodeDomain = (domain) => {
  if (!domain)
    return ["0"];
  const encoded = [];
  for (const subdomain of domain.replace(".stark", "").split("."))
    encoded.push(starknetId.useEncoded(subdomain).toString(10));
  return encoded;
};

// src/hooks/useStarkName.ts
import { useMemo as useMemo6 } from "react";
import {
  CallData as CallData3,
  Provider as Provider2,
  starknetId as starknetId2
} from "starknet";
function useStarkName({
  address,
  contract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  const enabled = useMemo6(
    () => Boolean(enabled_ && address),
    [enabled_, address]
  );
  return useQuery({
    queryKey: queryKey6({ address, contract, network: chain.network }),
    queryFn: queryFn6({ address, contract, provider, network: chain.network }),
    enabled,
    ...props
  });
}
function queryKey6({
  address,
  contract,
  network
}) {
  return [{ entity: "starkName", address, contract, network }];
}
function queryFn6({
  address,
  contract,
  provider,
  network
}) {
  return async function() {
    if (!address)
      throw new Error("address is required");
    const namingContract = contract ?? StarknetIdNamingContract2[network];
    const p = new Provider2(provider);
    try {
      const calldata = {
        contractAddress: namingContract,
        entrypoint: "address_to_domain",
        calldata: CallData3.compile({
          address,
          hint: []
        })
      };
      const fallbackCalldata = {
        contractAddress: namingContract,
        entrypoint: "address_to_domain",
        calldata: CallData3.compile({
          address
        })
      };
      const hexDomain = await executeWithFallback(
        p,
        calldata,
        fallbackCalldata
      );
      const decimalDomain = hexDomain.result.map((element) => BigInt(element)).slice(1);
      const stringDomain = starknetId2.useDecoded(decimalDomain);
      if (!stringDomain) {
        throw new Error("Could not get stark name");
      }
      return stringDomain;
    } catch (e) {
      throw new Error("Could not get stark name");
    }
  };
}
var executeWithFallback = async (provider, initialCall, fallbackCall) => {
  try {
    return await provider.callContract(initialCall);
  } catch (initialError) {
    try {
      return await provider.callContract(fallbackCall);
    } catch (fallbackError) {
      throw fallbackError;
    }
  }
};
var StarknetIdNamingContract2 = {
  goerli: "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",
  sepolia: "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474",
  mainnet: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678"
};

// src/hooks/useWaitForTransaction.ts
import { useMemo as useMemo7 } from "react";
function useWaitForTransaction({
  hash: hash2,
  watch,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider, chain } = useStarknet();
  const queryKey_ = useMemo7(() => queryKey7({ chain, hash: hash2 }), [chain, hash2]);
  const enabled = useMemo7(() => Boolean(enabled_ && hash2), [enabled_, hash2]);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    queryKey: queryKey_,
    queryFn: queryFn7({ provider, hash: hash2 }),
    enabled,
    ...props
  });
}
function queryKey7({ chain, hash: hash2 }) {
  return [
    { entity: "transactionReceipt", chainId: chain?.name, hash: hash2 }
  ];
}
function queryFn7({
  provider,
  hash: hash2
}) {
  return async function() {
    if (!hash2)
      throw new Error("hash is required");
    return await provider.getTransactionReceipt(hash2);
  };
}

// src/hooks/useStarkProfile.ts
import { useMemo as useMemo8 } from "react";
import {
  CairoCustomEnum,
  cairo,
  hash,
  shortString as shortString2,
  starknetId as starknetId3
} from "starknet";
function useStarkProfile({
  address,
  useDefaultPfp = true,
  namingContract,
  identityContract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  if (!StarknetIdcontracts[chain.network])
    throw new Error("Network not supported");
  const { contract: multicallContract } = useContract({
    abi: multicallABI,
    address: StarknetIdcontracts[chain.network]["multicall"]
  });
  const enabled = useMemo8(
    () => Boolean(enabled_ && address),
    [enabled_, address]
  );
  return useQuery({
    queryKey: queryKey8({ address, namingContract, identityContract }),
    queryFn: queryFn8({
      address,
      useDefaultPfp,
      namingContract,
      provider,
      network: chain.network,
      identityContract,
      multicallContract
    }),
    enabled,
    ...props
  });
}
function queryKey8({
  address,
  namingContract,
  identityContract
}) {
  return [
    { entity: "starkprofile", address, namingContract, identityContract }
  ];
}
function queryFn8({
  address,
  useDefaultPfp,
  namingContract,
  identityContract,
  provider,
  network,
  multicallContract
}) {
  return async function() {
    if (!address)
      throw new Error("address is required");
    if (!multicallContract)
      throw new Error("multicallContract is required");
    if (!network)
      throw new Error("network is required");
    const contracts = StarknetIdcontracts[network];
    const identity = identityContract ?? contracts["identity"];
    const naming = namingContract ?? contracts["naming"];
    const { initialCalldata, fallbackCalldata } = getStarkProfileCalldata(
      address,
      naming,
      identity,
      contracts
    );
    const data = await executeMulticallWithFallback(
      multicallContract,
      "aggregate",
      initialCalldata,
      fallbackCalldata
    );
    if (Array.isArray(data)) {
      const name = data[0][0] !== BigInt(0) ? starknetId3.useDecoded(data[0].slice(1)) : void 0;
      const twitter = data[2][0] !== BigInt(0) ? data[2][0].toString() : void 0;
      const github = data[3][0] !== BigInt(0) ? data[3][0].toString() : void 0;
      const discord = data[4][0] !== BigInt(0) ? data[4][0].toString() : void 0;
      const proofOfPersonhood = data[5][0] === BigInt(1) ? true : false;
      const profile = data.length === 9 ? data[8].slice(1).map(
        (val) => shortString2.decodeShortString(val.toString())
      ).join("") : void 0;
      const profilePicture = profile ? profile.includes("base64") ? JSON.parse(atob(profile.split(",")[1].slice(0, -1))).image : await fetchImageUrl(profile) : useDefaultPfp ? `https://starknet.id/api/identicons/${data[1][0].toString()}` : void 0;
      return {
        name,
        twitter,
        github,
        discord,
        proofOfPersonhood,
        profilePicture,
        profile
      };
    } else {
      throw new Error("Error while fetching data");
    }
  };
}
var hardcoded = (arg) => {
  return new CairoCustomEnum({
    Hardcoded: arg
  });
};
var reference = (call, pos) => {
  return new CairoCustomEnum({
    Reference: cairo.tuple(call, pos)
  });
};
var arrayReference = (call, pos) => {
  return new CairoCustomEnum({
    ArrayReference: cairo.tuple(call, pos)
  });
};
var staticExecution = () => {
  return new CairoCustomEnum({
    Static: {}
  });
};
var notEqual = (call, pos, value) => {
  return new CairoCustomEnum({
    IfNotEqual: cairo.tuple(call, pos, value)
  });
};
var fetchImageUrl = async (url) => {
  try {
    const response = await fetch(parseImageUrl(url));
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    const data = await response.json();
    if (data.image) {
      return parseImageUrl(data.image);
    } else {
      return "Image is not set";
    }
  } catch (error) {
    console.error("There was a problem fetching the image URL:", error);
    return "Error fetching data";
  }
};
var parseImageUrl = (url) => {
  return url.startsWith("ipfs://") ? url.replace("ipfs://", "https://gateway.pinata.cloud/ipfs/") : url;
};
var StarknetIdcontracts = {
  goerli: {
    naming: "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",
    identity: "0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d",
    verifier: "0x019e5204152a72891bf8cd0bed8f03593fdb29ceacd14fca587be5d9fcf87c0e",
    verifier_pop: "0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106",
    verifier_pfp: "0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698",
    multicall: "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
  },
  sepolia: {
    naming: "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474",
    identity: "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda",
    verifier: "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566",
    verifier_pop: "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a",
    verifier_pfp: "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02",
    multicall: "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
  },
  mainnet: {
    naming: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678",
    identity: "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af",
    verifier: "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf",
    verifier_pop: "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4",
    verifier_pfp: "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7",
    multicall: "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
  }
};
var executeMulticallWithFallback = async (contract, functionName, initialCalldata, fallbackCalldata) => {
  try {
    return await contract.call(functionName, [initialCalldata]);
  } catch (initialError) {
    try {
      return await contract.call(functionName, [fallbackCalldata]);
    } catch (fallbackError) {
      throw fallbackError;
    }
  }
};
var getStarkProfileCalldata = (address, namingContract, identityContract, contracts) => {
  let initialCalldata = [];
  let fallbackCalldata = [];
  initialCalldata.push({
    execution: staticExecution(),
    to: hardcoded(namingContract),
    selector: hardcoded(hash.getSelectorFromName("address_to_domain")),
    calldata: [hardcoded(address), hardcoded("0")]
  });
  fallbackCalldata.push({
    execution: staticExecution(),
    to: hardcoded(namingContract),
    selector: hardcoded(hash.getSelectorFromName("address_to_domain")),
    calldata: [hardcoded(address)]
  });
  const calls = [
    {
      execution: staticExecution(),
      to: hardcoded(namingContract),
      selector: hardcoded(hash.getSelectorFromName("domain_to_id")),
      calldata: [arrayReference(0, 0)]
    },
    {
      execution: staticExecution(),
      to: hardcoded(identityContract),
      selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
      calldata: [
        reference(1, 0),
        hardcoded(shortString2.encodeShortString("twitter")),
        hardcoded(contracts["verifier"]),
        hardcoded("0")
      ]
    },
    {
      execution: staticExecution(),
      to: hardcoded(identityContract),
      selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
      calldata: [
        reference(1, 0),
        hardcoded(shortString2.encodeShortString("github")),
        hardcoded(contracts["verifier"]),
        hardcoded("0")
      ]
    },
    {
      execution: staticExecution(),
      to: hardcoded(identityContract),
      selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
      calldata: [
        reference(1, 0),
        hardcoded(shortString2.encodeShortString("discord")),
        hardcoded(contracts["verifier"]),
        hardcoded("0")
      ]
    },
    {
      execution: staticExecution(),
      to: hardcoded(identityContract),
      selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
      calldata: [
        reference(1, 0),
        hardcoded(shortString2.encodeShortString("proof_of_personhood")),
        hardcoded(contracts["verifier_pop"]),
        hardcoded("0")
      ]
    },
    // PFP
    {
      execution: staticExecution(),
      to: hardcoded(identityContract),
      selector: hardcoded(hash.getSelectorFromName("get_verifier_data")),
      calldata: [
        reference(1, 0),
        hardcoded(shortString2.encodeShortString("nft_pp_contract")),
        hardcoded(contracts["verifier_pfp"]),
        hardcoded("0")
      ]
    },
    {
      execution: staticExecution(),
      to: hardcoded(identityContract),
      selector: hardcoded(
        hash.getSelectorFromName("get_extended_verifier_data")
      ),
      calldata: [
        reference(1, 0),
        hardcoded(shortString2.encodeShortString("nft_pp_id")),
        hardcoded("2"),
        hardcoded(contracts["verifier_pfp"]),
        hardcoded("0")
      ]
    },
    {
      execution: notEqual(6, 0, 0),
      to: reference(6, 0),
      selector: hardcoded(hash.getSelectorFromName("tokenURI")),
      calldata: [reference(7, 1), reference(7, 2)]
    }
  ];
  initialCalldata.push(...calls);
  fallbackCalldata.push(...calls);
  return { initialCalldata, fallbackCalldata };
};
var multicallABI = [
  {
    type: "impl",
    name: "ComposableMulticallImpl",
    interface_name: "composable_multicall::IComposableMulticall"
  },
  {
    type: "enum",
    name: "composable_multicall::Execution",
    variants: [
      { name: "Static", type: "()" },
      {
        name: "IfEqual",
        type: "(core::integer::u32, core::integer::u32, core::felt252)"
      },
      {
        name: "IfNotEqual",
        type: "(core::integer::u32, core::integer::u32, core::felt252)"
      }
    ]
  },
  {
    type: "enum",
    name: "composable_multicall::DynamicFelt",
    variants: [
      { name: "Hardcoded", type: "core::felt252" },
      { name: "Reference", type: "(core::integer::u32, core::integer::u32)" }
    ]
  },
  {
    type: "enum",
    name: "composable_multicall::DynamicCalldata",
    variants: [
      { name: "Hardcoded", type: "core::felt252" },
      { name: "Reference", type: "(core::integer::u32, core::integer::u32)" },
      {
        name: "ArrayReference",
        type: "(core::integer::u32, core::integer::u32)"
      }
    ]
  },
  {
    type: "struct",
    name: "composable_multicall::DynamicCall",
    members: [
      { name: "execution", type: "composable_multicall::Execution" },
      { name: "to", type: "composable_multicall::DynamicFelt" },
      { name: "selector", type: "composable_multicall::DynamicFelt" },
      {
        name: "calldata",
        type: "core::array::Array::<composable_multicall::DynamicCalldata>"
      }
    ]
  },
  {
    type: "struct",
    name: "core::array::Span::<core::felt252>",
    members: [
      { name: "snapshot", type: "@core::array::Array::<core::felt252>" }
    ]
  },
  {
    type: "interface",
    name: "composable_multicall::IComposableMulticall",
    items: [
      {
        type: "function",
        name: "aggregate",
        inputs: [
          {
            name: "calls",
            type: "core::array::Array::<composable_multicall::DynamicCall>"
          }
        ],
        outputs: [
          { type: "core::array::Array::<core::array::Span::<core::felt252>>" }
        ],
        state_mutability: "view"
      }
    ]
  },
  {
    type: "event",
    name: "composable_multicall::contract::ComposableMulticall::Event",
    kind: "enum",
    variants: []
  }
];

// src/hooks/useEstimateFees.ts
import { useMemo as useMemo9 } from "react";
function useEstimateFees({
  calls,
  options,
  watch = false,
  enabled: enabled_ = true,
  ...props
}) {
  const { account } = useAccount();
  const queryKey_ = useMemo9(
    () => queryKey9({ calls, options }),
    [calls, options]
  );
  const enabled = useMemo9(() => Boolean(enabled_ && calls), [enabled_, calls]);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    enabled,
    queryKey: queryKey_,
    queryFn: queryFn9({
      account,
      calls,
      options
    }),
    ...props
  });
}
function queryKey9({ calls, options }) {
  return [
    {
      entity: "estimateInvokeFee",
      calls,
      options
    }
  ];
}
function queryFn9({
  account,
  calls,
  options
}) {
  return async function() {
    if (!account)
      throw new Error("account is required");
    if (!calls || calls.length === 0)
      throw new Error("calls are required");
    return account?.estimateInvokeFee(calls, options);
  };
}
export {
  useAccount,
  useBalance,
  useBlock,
  useBlockNumber,
  useConnect,
  useContract,
  useContractFactory,
  useContractRead,
  useContractWrite,
  useDeployAccount,
  useDisconnect,
  useEstimateFees,
  useExplorer,
  useInvalidateOnBlock,
  useNetwork,
  useProvider,
  useSignTypedData,
  useStarkAddress,
  useStarkName,
  useStarkProfile,
  useWaitForTransaction
};
//# sourceMappingURL=index.js.map