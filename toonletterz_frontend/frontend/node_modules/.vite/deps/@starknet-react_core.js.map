{
  "version": 3,
  "sources": ["../../eventemitter3/index.js", "../../eventemitter3/index.mjs", "../../@starknet-react/core/src/connectors/base.ts", "../../@starknet-react/core/src/connectors/injected.ts", "../../@starknet-react/core/src/errors.ts", "../../@starknet-react/core/src/connectors/discovery.ts", "../../@starknet-react/core/src/connectors/helpers.ts", "../../@starknet-react/core/src/connectors/mobile.ts", "../../@starknet-react/core/src/connectors/mock.ts", "../../@starknet-react/core/src/context/starknet.tsx", "../../@starknet-react/core/src/context/account.tsx", "../../@starknet-react/core/src/context/index.tsx", "../../@starknet-react/core/src/explorers/starkCompass.ts", "../../@starknet-react/core/src/explorers/starkscan.ts", "../../@starknet-react/core/src/explorers/viewblock.ts", "../../@starknet-react/core/src/explorers/voyager.ts", "../../@starknet-react/core/src/hooks/useAccount.ts", "../../@starknet-react/core/src/hooks/useConnect.ts", "../../@starknet-react/core/src/query.ts", "../../@starknet-react/core/src/hooks/useBalance.ts", "../../@starknet-react/core/src/hooks/useContract.ts", "../../@starknet-react/core/src/hooks/useInvalidateOnBlock.ts", "../../@starknet-react/core/src/hooks/useBlockNumber.ts", "../../@starknet-react/core/src/hooks/useNetwork.ts", "../../@starknet-react/core/src/hooks/useBlock.ts", "../../@starknet-react/core/src/hooks/useContractFactory.ts", "../../@starknet-react/core/src/hooks/useContractRead.ts", "../../@starknet-react/core/src/hooks/useContractWrite.ts", "../../@starknet-react/core/src/hooks/useExplorer.ts", "../../@starknet-react/core/src/hooks/useDeployAccount.ts", "../../@starknet-react/core/src/hooks/useDisconnect.ts", "../../@starknet-react/core/src/hooks/useProvider.ts", "../../@starknet-react/core/src/hooks/useSign.ts", "../../@starknet-react/core/src/hooks/useStarkAddress.ts", "../../@starknet-react/core/src/hooks/useStarkName.ts", "../../@starknet-react/core/src/hooks/useWaitForTransaction.ts", "../../@starknet-react/core/src/hooks/useStarkProfile.ts", "../../@starknet-react/core/src/hooks/useEstimateFees.ts", "../../@starknet-react/core/src/providers/jsonrpc.ts", "../../@starknet-react/core/src/providers/public.ts", "../../@starknet-react/core/src/providers/alchemy.ts", "../../@starknet-react/core/src/providers/blast.ts", "../../@starknet-react/core/src/providers/infura.ts", "../../@starknet-react/core/src/providers/lava.ts", "../../@starknet-react/core/src/providers/nethermind.ts", "../../@starknet-react/core/src/providers/reddio.ts", "../../@tanstack/query-core/src/subscribable.ts", "../../@tanstack/query-core/src/utils.ts", "../../@tanstack/query-core/src/focusManager.ts", "../../@tanstack/query-core/src/onlineManager.ts", "../../@tanstack/query-core/src/thenable.ts", "../../@tanstack/query-core/src/retryer.ts", "../../@tanstack/query-core/src/notifyManager.ts", "../../@tanstack/query-core/src/removable.ts", "../../@tanstack/query-core/src/query.ts", "../../@tanstack/query-core/src/queryCache.ts", "../../@tanstack/query-core/src/mutation.ts", "../../@tanstack/query-core/src/mutationCache.ts", "../../@tanstack/query-core/src/infiniteQueryBehavior.ts", "../../@tanstack/query-core/src/queryClient.ts", "../../@tanstack/query-core/src/queryObserver.ts", "../../@tanstack/query-core/src/mutationObserver.ts", "../../@tanstack/query-core/src/types.ts", "../../@tanstack/react-query/src/useQueries.ts", "../../@tanstack/react-query/src/QueryClientProvider.tsx", "../../@tanstack/react-query/src/IsRestoringProvider.ts", "../../@tanstack/react-query/src/QueryErrorResetBoundary.tsx", "../../@tanstack/react-query/src/errorBoundaryUtils.ts", "../../@tanstack/react-query/src/suspense.ts", "../../@tanstack/react-query/src/useBaseQuery.ts", "../../@tanstack/react-query/src/useQuery.ts", "../../@tanstack/react-query/src/HydrationBoundary.tsx", "../../@tanstack/react-query/src/useIsFetching.ts", "../../@tanstack/react-query/src/useMutationState.ts", "../../@tanstack/react-query/src/useMutation.ts", "../../zod/dist/esm/v3/external.js", "../../zod/dist/esm/v3/helpers/util.js", "../../zod/dist/esm/v3/ZodError.js", "../../zod/dist/esm/v3/locales/en.js", "../../zod/dist/esm/v3/errors.js", "../../zod/dist/esm/v3/helpers/parseUtil.js", "../../zod/dist/esm/v3/helpers/errorUtil.js", "../../zod/dist/esm/v3/types.js"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "import EventEmitter from \"eventemitter3\";\nimport { AccountInterface } from \"starknet\";\n\n/** Connector icons, as base64 encoded svg. */\nexport type ConnectorIcons = {\n  /** Dark-mode icon. */\n  dark?: string;\n  /** Light-mode icon. */\n  light?: string;\n};\n\n/** Connector data. */\nexport type ConnectorData = {\n  /** Connector account. */\n  account?: string;\n  /** Connector network. */\n  chainId?: bigint;\n};\n\n/** Connector events. */\nexport interface ConnectorEvents {\n  /** Emitted when account or network changes. */\n  change(data: ConnectorData): void;\n  /** Emitted when connection is established. */\n  connect(data: ConnectorData): void;\n  /** Emitted when connection is lost. */\n  disconnect(): void;\n}\n\nexport abstract class Connector extends EventEmitter<ConnectorEvents> {\n  /** Unique connector id. */\n  abstract get id(): string;\n  /** Connector name. */\n  abstract get name(): string;\n  /** Connector icons. */\n  abstract get icon(): ConnectorIcons;\n\n  /** Whether connector is available for use */\n  abstract available(): boolean;\n  /** Whether connector is already authorized */\n  abstract ready(): Promise<boolean>;\n  /** Connect wallet. */\n  abstract connect(): Promise<ConnectorData>;\n  /** Disconnect wallet. */\n  abstract disconnect(): Promise<void>;\n  /** Get current account. */\n  abstract account(): Promise<AccountInterface>;\n  /** Get current chain id. */\n  abstract chainId(): Promise<bigint>;\n}\n", "import { goerli, mainnet, sepolia } from \"@starknet-react/chains\";\nimport { StarknetWindowObject } from \"get-starknet-core\";\nimport { AccountInterface } from \"starknet\";\nimport {\n  ConnectorNotConnectedError,\n  ConnectorNotFoundError,\n  UserNotConnectedError,\n  UserRejectedRequestError,\n} from \"../errors\";\nimport { Connector, ConnectorData, ConnectorIcons } from \"./base\";\n\n/** Injected connector options. */\nexport interface InjectedConnectorOptions {\n  /** The wallet id. */\n  id: string;\n  /** Wallet human readable name. */\n  name?: string;\n  /** Wallet icons. */\n  icon?: ConnectorIcons;\n}\n\n// Icons used when the injected wallet is not found and no icon is provided.\n// question-mark-circle from heroicons with color changed to black/white.\nconst WALLET_NOT_FOUND_ICON_LIGHT =\n  \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+\";\nconst WALLET_NOT_FOUND_ICON_DARK =\n  \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==\";\n\n//  Icons used when the injected wallet is not installed\n//  Icons from media kits\nconst walletIcons = {\n  argentX:\n    \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2NS4xOTUwOCA1Ny43MzU2MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjUuMTk1MDggNTcuNzM1NjI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkY4NzVCO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTQwLjk4NTkyLDBIMjQuMjA4ODhjLTAuNTYsMC0xLjAxMDAxLDAuNDUxMDItMS4wMjE5NywxLjAxMjAyCgljLTAuMzM4OTksMTUuNzU1LTguNTgyMDMsMzAuNzA4OTgtMjIuNzcwMDIsNDEuMzAwOTljLTAuNDUwMDEsMC4zMzcwMS0wLjU1Mjk4LDAuOTY3OTktMC4yMjQsMS40MjNsOS44MTU5OCwxMy41NzMKCWMwLjMzNDA1LDAuNDYyMDEsMC45ODUwNSwwLjU2NTk4LDEuNDQyOTksMC4yMjY5OWM4Ljg3MTAzLTYuNTc5MDEsMTYuMDA3MDItMTQuNTE3LDIxLjE0NjA2LTIzLjMxNQoJYzUuMTM4LDguNzk4LDEyLjI3Mzk5LDE2LjczNTk5LDIxLjE0NiwyMy4zMTVjMC40NTY5NywwLjMzODk5LDEuMTA3OTcsMC4yMzUwMiwxLjQ0MTk2LTAuMjI2OTlsOS44MTYwNC0xMy41NzMKCWMwLjMyODk4LTAuNDU1MDIsMC4yMjY5OS0xLjA4Ni0wLjIyNC0xLjQyM0M1MC41ODk4NiwzMS43MjEwMSw0Mi4zNDY4OCwxNi43NjcwMyw0Mi4wMDc4OSwxLjAxMjAyCglDNDEuOTk1ODcsMC40NTEwMiw0MS41NDY4OSwwLDQwLjk4NTkyLDAiLz4KPC9zdmc+Cg==\",\n  braavos:\n    \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=\",\n};\nexport class InjectedConnector extends Connector {\n  private _wallet?: StarknetWindowObject;\n  private _options: InjectedConnectorOptions;\n\n  constructor({ options }: { options: InjectedConnectorOptions }) {\n    super();\n    this._options = options;\n  }\n\n  get id(): string {\n    return this._options.id;\n  }\n\n  get name(): string {\n    return this._options.name ?? this._wallet?.name ?? this._options.id;\n  }\n\n  get icon(): ConnectorIcons {\n    let defaultIcon = {\n      dark:\n        this._wallet?.icon ||\n        walletIcons[this.id as keyof typeof walletIcons] ||\n        WALLET_NOT_FOUND_ICON_DARK,\n      light:\n        this._wallet?.icon ||\n        walletIcons[this.id as keyof typeof walletIcons] ||\n        WALLET_NOT_FOUND_ICON_LIGHT,\n    };\n\n    return this._options.icon ?? defaultIcon;\n  }\n\n  available(): boolean {\n    this.ensureWallet();\n    return this._wallet !== undefined;\n  }\n\n  async chainId(): Promise<bigint> {\n    this.ensureWallet();\n\n    if (!this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    const chainIdHex = await this._wallet.provider.getChainId();\n    const chainId = BigInt(chainIdHex);\n    return chainId;\n  }\n\n  async ready(): Promise<boolean> {\n    this.ensureWallet();\n\n    if (!this._wallet) return false;\n    return await this._wallet.isPreauthorized();\n  }\n\n  async connect(): Promise<ConnectorData> {\n    this.ensureWallet();\n\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n\n    let accounts;\n    try {\n      accounts = await this._wallet.enable({ starknetVersion: \"v5\" });\n    } catch {\n      // NOTE: Argent v3.0.0 swallows the `.enable` call on reject, so this won't get hit.\n      throw new UserRejectedRequestError();\n    }\n\n    if (!this._wallet.isConnected || !accounts) {\n      // NOTE: Argent v3.0.0 swallows the `.enable` call on reject, so this won't get hit.\n      throw new UserRejectedRequestError();\n    }\n\n    this._wallet.on(\"accountsChanged\", async (accounts: string[] | string) => {\n      await this.onAccountsChanged(accounts);\n    });\n\n    this._wallet.on(\"networkChanged\", (network?: string) => {\n      this.onNetworkChanged(network);\n    });\n\n    await this.onAccountsChanged(accounts);\n\n    const account = this._wallet.account.address;\n    const chainId = await this.chainId();\n\n    this.emit(\"connect\", { account, chainId });\n\n    return {\n      account,\n      chainId,\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    this.ensureWallet();\n\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n\n    if (!this._wallet?.isConnected) {\n      throw new UserNotConnectedError();\n    }\n\n    this.emit(\"disconnect\");\n  }\n\n  async account(): Promise<AccountInterface> {\n    this.ensureWallet();\n\n    if (!this._wallet || !this._wallet.account) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return this._wallet.account;\n  }\n\n  private ensureWallet() {\n    const installed = getAvailableWallets(globalThis);\n    const wallet = installed.filter((w) => w.id === this._options.id)[0];\n    if (wallet) {\n      this._wallet = wallet;\n    }\n  }\n\n  private async onAccountsChanged(accounts: string[] | string): Promise<void> {\n    let account;\n    if (typeof accounts === \"string\") {\n      account = accounts;\n    } else {\n      account = accounts[0];\n    }\n\n    if (account) {\n      const chainId = await this.chainId();\n      this.emit(\"change\", { account, chainId });\n    } else {\n      this.emit(\"disconnect\");\n    }\n  }\n\n  private onNetworkChanged(network?: string): void {\n    switch (network) {\n      // Argent\n      case \"SN_MAIN\":\n        this.emit(\"change\", { chainId: mainnet.id });\n        break;\n      case \"SN_GOERLI\":\n        this.emit(\"change\", { chainId: goerli.id });\n        break;\n      case \"SN_SEPOLIA\":\n        this.emit(\"change\", { chainId: sepolia.id });\n        break;\n      // Braavos\n      case \"mainnet-alpha\":\n        this.emit(\"change\", { chainId: mainnet.id });\n        break;\n      case \"goerli-alpha\":\n        this.emit(\"change\", { chainId: goerli.id });\n        break;\n      case \"sepolia-alpha\":\n        this.emit(\"change\", { chainId: sepolia.id });\n        break;\n      default:\n        this.emit(\"change\", {});\n        break;\n    }\n  }\n}\n\n// biome-ignore lint: window could contain anything\nfunction getAvailableWallets(obj: Record<string, any>): StarknetWindowObject[] {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce<\n      Record<string, StarknetWindowObject>\n    >((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet as StarknetWindowObject;\n        }\n      }\n      return wallets;\n    }, {}),\n  );\n}\n\n// biome-ignore lint: wallet could be anything\nfunction isWalletObject(wallet: any): boolean {\n  try {\n    return (\n      wallet &&\n      [\n        // wallet's must have methods/members, see IStarknetWindowObject\n        \"request\",\n        \"isConnected\",\n        \"provider\",\n        \"enable\",\n        \"isPreauthorized\",\n        \"on\",\n        \"off\",\n        \"version\",\n        \"id\",\n        \"name\",\n        \"icon\",\n      ].every((key) => key in wallet)\n    );\n  } catch (err) {}\n  return false;\n}\n", "export class ConnectorAlreadyConnectedError extends Error {\n  override name = \"ConnectorAlreadyConnectedError\";\n  override message = \"Connector already connected\";\n}\n\nexport class ConnectorNotConnectedError extends Error {\n  override name = \"ConnectorNotConnectedError\";\n  override message = \"Connector not connected\";\n}\n\nexport class ConnectorNotFoundError extends Error {\n  override name = \"ConnectorNotFoundError\";\n  override message = \"Connector not found\";\n}\n\nexport class UserRejectedRequestError extends Error {\n  override name = \"UserRejectedRequestError\";\n  override message = \"User rejected request\";\n}\n\nexport class UserNotConnectedError extends Error {\n  override name = \"UserNotConnectedError\";\n  override message = \"User not connected\";\n}\n\nexport class UnsupportedAccountInterfaceError extends Error {\n  override name = \"UnsupportedAccountInterfaceError\";\n  override message =\n    \"Unsupported account interface. starknet-react v1 only supports the starknet.js v5 account interface\";\n}\n", "import type { StarknetWindowObject } from \"get-starknet-core\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\nimport { Connector } from \"./base\";\nimport { injected } from \"./helpers\";\nimport { withMobileConnector } from \"~/connectors/mobile\";\n\nexport type UseInjectedConnectorsProps = {\n  /** List of recommended connectors to display. */\n  recommended?: Connector[];\n  /** Whether to include recommended connectors in the list. */\n  includeRecommended?: \"always\" | \"onlyIfNoConnectors\";\n  /** How to order connectors. */\n  order?: \"random\" | \"alphabetical\";\n};\n\nexport type UseInjectedConnectorsResult = {\n  /** Connectors list. */\n  connectors: Connector[];\n};\n\nexport function useInjectedConnectors({\n  recommended,\n  includeRecommended = \"always\",\n  order = \"alphabetical\",\n}: UseInjectedConnectorsProps): UseInjectedConnectorsResult {\n  const [injectedConnectors, setInjectedConnectors] = useState<Connector[]>([]);\n\n  const refreshConnectors = useCallback(() => {\n    const wallets = scanObjectForWallets(window);\n    const connectors = wallets.map((wallet) => injected({ id: wallet.id }));\n    setInjectedConnectors(connectors);\n  }, [setInjectedConnectors]);\n\n  useEffect(() => {\n    refreshConnectors();\n  }, [refreshConnectors]);\n\n  const connectors = useMemo(() => {\n    return mergeConnectors(injectedConnectors, recommended ?? [], {\n      includeRecommended,\n      order,\n    });\n  }, [injectedConnectors, recommended, includeRecommended, order]);\n\n  return { connectors: withMobileConnector(connectors) };\n}\n\nfunction mergeConnectors(\n  injected: Connector[],\n  recommended: Connector[],\n  {\n    includeRecommended,\n    order,\n  }: Required<Pick<UseInjectedConnectorsProps, \"includeRecommended\" | \"order\">>,\n): Connector[] {\n  const injectedIds = new Set(injected.map((connector) => connector.id));\n  const allConnectors = [...injected];\n  const shouldAddRecommended =\n    includeRecommended === \"always\" ||\n    (includeRecommended === \"onlyIfNoConnectors\" && injected.length === 0);\n  if (shouldAddRecommended) {\n    allConnectors.push(\n      ...recommended.filter((connector) => !injectedIds.has(connector.id)),\n    );\n  }\n\n  if (order === \"random\") {\n    return shuffle(allConnectors);\n  }\n  return allConnectors.sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction shuffle<T>(arr: T[]): T[] {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    // @ts-ignore: not important\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\n\nexport function scanObjectForWallets(\n  // biome-ignore lint: window could contain anything\n  obj: Record<string, any>,\n): StarknetWindowObject[] {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce<\n      Record<string, StarknetWindowObject>\n    >((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet;\n        }\n      }\n      return wallets;\n    }, {}),\n  );\n}\n\n// biome-ignore lint: window could contain anything\nfunction isWalletObject(wallet: any): wallet is StarknetWindowObject {\n  try {\n    return (\n      wallet &&\n      [\n        // wallet's must have methods/members, see IStarknetWindowObject\n        \"request\",\n        \"isConnected\",\n        \"provider\",\n        \"enable\",\n        \"isPreauthorized\",\n        \"on\",\n        \"off\",\n        \"version\",\n        \"id\",\n        \"name\",\n        \"icon\",\n      ].every((key) => key in wallet)\n    );\n  } catch (err) {}\n  return false;\n}\n", "import { InjectedConnector } from \"./injected\";\n\nexport function argent(): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id: \"argentX\",\n      name: \"Argent\",\n    },\n  });\n}\n\nexport function braavos(): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id: \"braavos\",\n      name: \"Braavos\",\n    },\n  });\n}\n\nexport function injected({ id }: { id: string }): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id,\n    },\n  });\n}\n", "import { Connector } from \"~/connectors/base\";\nimport { braavos } from \"~/connectors/helpers\";\n\nexport const isMobile = (): boolean => {\n  const userAgent =\n    typeof window !== \"undefined\" ? window.navigator?.userAgent : \"\";\n  return /Android|iPhone|iPad|iPod/i.test(userAgent);\n};\n\nexport const withMobileConnector = (connectors: Connector[]): Connector[] => {\n  if (\n    isMobile() &&\n    // In the context of a mobile browser, `starknet_braavos` is only injected\n    // if the dApp is launched within the Braavos in-app dApp browser\n    !!window.starknet_braavos\n  ) {\n    return [braavos()];\n  }\n\n  return connectors;\n};\n", "import { goerli, mainnet } from \"@starknet-react/chains\";\nimport { AccountInterface } from \"starknet\";\nimport {\n  ConnectorNotConnectedError,\n  ConnectorNotFoundError,\n  UserRejectedRequestError,\n} from \"../errors\";\nimport { Connector, ConnectorData, ConnectorIcons } from \"./base\";\n\nexport type MockConnectorOptions = {\n  /** The wallet id. */\n  id: string;\n  /** Wallet human readable name. */\n  name: string;\n  /** Wallet icons. */\n  icon: ConnectorIcons;\n  /** Whether the connector is available for use. */\n  available?: boolean;\n  /** Whether the connector should fail to connect. */\n  failConnect?: boolean;\n  /** Include account when switching chain. */\n  unifiedSwitchAccountAndChain?: boolean;\n  /** Emit change account event when switching chain. */\n  emitChangeAccountOnChainSwitch?: boolean;\n};\n\nexport type MockConnectorAccounts = {\n  goerli: AccountInterface[];\n  mainnet: AccountInterface[];\n};\n\nexport class MockConnector extends Connector {\n  private _accounts: MockConnectorAccounts;\n  private _accountIndex = 0;\n  private _options: MockConnectorOptions;\n  private _connected = false;\n  private _chainId: bigint = goerli.id;\n\n  constructor({\n    accounts,\n    options,\n  }: { accounts: MockConnectorAccounts; options: MockConnectorOptions }) {\n    super();\n\n    if (accounts.mainnet.length === 0 || accounts.goerli.length === 0) {\n      throw new Error(\"MockConnector: accounts must not be empty\");\n    }\n\n    this._accounts = accounts;\n    this._options = options;\n  }\n\n  switchChain(chainId: bigint): void {\n    this._chainId = chainId;\n    this._accountIndex = 0;\n    let account;\n    if (this._options.unifiedSwitchAccountAndChain) {\n      account = this._account.address;\n    }\n\n    this.emit(\"change\", { chainId, account });\n\n    if (this._options.emitChangeAccountOnChainSwitch ?? true) {\n      this.switchAccount(this._accountIndex);\n    }\n  }\n\n  switchAccount(accountIndex: number): void {\n    this._accountIndex = accountIndex;\n    this.emit(\"change\", { account: this._account.address });\n  }\n\n  get id(): string {\n    return this._options.id;\n  }\n\n  get name(): string {\n    return this._options.name;\n  }\n\n  get icon(): ConnectorIcons {\n    return this._options.icon;\n  }\n\n  available(): boolean {\n    return this._options.available ?? true;\n  }\n\n  async chainId(): Promise<bigint> {\n    return this._chainId;\n  }\n\n  async ready(): Promise<boolean> {\n    return this._connected;\n  }\n\n  async connect(): Promise<ConnectorData> {\n    if (this._options.failConnect) {\n      throw new UserRejectedRequestError();\n    }\n\n    this._connected = true;\n\n    return {\n      account: this._account.address,\n      chainId: this._chainId,\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    this._connected = false;\n\n    this.emit(\"disconnect\");\n  }\n\n  async account(): Promise<AccountInterface> {\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n\n    if (!this._connected) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return this._account;\n  }\n\n  private get _account(): AccountInterface {\n    let account;\n    if (this._chainId === mainnet.id) {\n      account = this._accounts.mainnet[this._accountIndex];\n    } else {\n      account = this._accounts.goerli[this._accountIndex];\n    }\n\n    if (!account) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return account;\n  }\n}\n", "import { Chain, goerli, mainnet, sepolia } from \"@starknet-react/chains\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { constants, AccountInterface, ProviderInterface } from \"starknet\";\n\nimport { Connector } from \"~/connectors\";\nimport { ConnectorData } from \"~/connectors/base\";\nimport { ConnectorNotFoundError } from \"~/errors\";\nimport { ChainProviderFactory } from \"~/providers\";\nimport { ExplorerFactory } from \"~/explorers/\";\nimport { AccountProvider } from \"./account\";\nimport { withMobileConnector } from \"~/connectors/mobile\";\n\nconst defaultQueryClient = new QueryClient();\n\n/** State of the Starknet context. */\nexport interface StarknetState {\n  /** Connected connector. */\n  connector?: Connector;\n  /** Connect the given connector. */\n  connect: ({ connector }: { connector?: Connector }) => Promise<void>;\n  /** Disconnect the currently connected connector. */\n  disconnect: () => Promise<void>;\n  /** List of registered connectors. */\n  connectors: Connector[];\n  /** Current explorer factory. */\n  explorer?: ExplorerFactory;\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Current chain. */\n  chain: Chain;\n  /** Current provider. */\n  provider: ProviderInterface;\n  /** Error. */\n  error?: Error;\n}\n\nconst StarknetContext = createContext<StarknetState | undefined>(undefined);\n\n/**\n * Returns the current Starknet context state.\n *\n * @remarks\n *\n * This hook should be used sparingly and will be deprecated.\n *\n * Use the following hooks:\n *\n *  - `account`: `useAccount`\n *  - `connect`, `disconnect`, `connectors`: `useConnectors`\n *\n * @example\n * This example shows how to access the Starknet provider.\n * ```tsx\n * function Component() {\n *   const { library } = useStarknet()\n *\n *   if (!library.provider) return <span>Account URL: {library.baseUrl}</span>\n *   return <span>Provider URL: {library.provider.baseUrl}</span>\n * }\n * ```\n */\nexport function useStarknet(): StarknetState {\n  const state = useContext(StarknetContext);\n  if (!state) {\n    throw new Error(\n      \"useStarknet must be used within a StarknetProvider or StarknetConfig\",\n    );\n  }\n  return state;\n}\n\ninterface StarknetManagerState {\n  currentChain: Chain;\n  connectors: Connector[];\n  currentAccount?: AccountInterface;\n  currentProvider: ProviderInterface;\n  error?: Error;\n}\n\ninterface UseStarknetManagerProps {\n  chains: Chain[];\n  provider: ChainProviderFactory;\n  explorer?: ExplorerFactory;\n  connectors?: Connector[];\n  autoConnect?: boolean;\n}\n\nfunction useStarknetManager({\n  chains,\n  provider,\n  explorer,\n  connectors = [],\n  autoConnect = false,\n}: UseStarknetManagerProps): StarknetState & { account?: AccountInterface } {\n  const initialChain = chains[0];\n  if (initialChain === undefined) {\n    throw new Error(\"Must provide at least one chain.\");\n  }\n\n  const { chain: defaultChain, provider: defaultProvider } = providerForChain(\n    initialChain,\n    provider,\n  );\n\n  // The currently connected connector needs to be accessible from the\n  // event handler.\n  const connectorRef = useRef<Connector | undefined>();\n  const [state, setState] = useState<StarknetManagerState>({\n    currentChain: defaultChain,\n    currentProvider: defaultProvider,\n    connectors: withMobileConnector(connectors),\n  });\n\n  const updateChainAndProvider = useCallback(\n    ({ chainId }: { chainId?: bigint }) => {\n      if (!chainId) return;\n      for (const chain of chains) {\n        if (chain.id === chainId) {\n          const { chain: newChain, provider: newProvider } = providerForChain(\n            chain,\n            provider,\n          );\n          setState((state) => ({\n            ...state,\n            currentChain: newChain,\n            currentProvider: newProvider,\n          }));\n          return;\n        }\n      }\n    },\n    [setState, chains],\n  );\n\n  const handleConnectorChange = useCallback(\n    async ({ chainId, account }: ConnectorData) => {\n      if (chainId) {\n        updateChainAndProvider({ chainId });\n      }\n\n      if (account && connectorRef.current) {\n        const account = await connectorRef.current.account();\n        setState((state) => ({\n          ...state,\n          currentAccount: account,\n        }));\n      }\n    },\n    [updateChainAndProvider, setState, connectorRef],\n  );\n\n  const connect = useCallback(\n    async ({ connector }: { connector?: Connector }) => {\n      if (!connector) {\n        throw new Error(\"Must provide a connector.\");\n      }\n\n      const needsListenerSetup = connectorRef.current?.id !== connector.id;\n      if (needsListenerSetup) {\n        connectorRef.current?.off(\"change\", handleConnectorChange);\n      }\n\n      try {\n        const { chainId } = await connector.connect();\n        const account = await connector.account();\n\n        if (account.address !== state.currentAccount?.address) {\n          connectorRef.current = connector;\n          setState((state) => ({\n            ...state,\n            currentAccount: account,\n          }));\n        }\n\n        if (autoConnect) {\n          localStorage.setItem(\"lastUsedConnector\", connector.id);\n        }\n\n        if (needsListenerSetup) {\n          connector.on(\"change\", handleConnectorChange);\n        }\n\n        updateChainAndProvider({ chainId });\n      } catch (err) {\n        setState((state) => ({\n          ...state,\n          error: new ConnectorNotFoundError(),\n        }));\n        throw err;\n      }\n    },\n    [\n      autoConnect,\n      setState,\n      connectorRef,\n      state.currentAccount,\n      handleConnectorChange,\n      updateChainAndProvider,\n    ],\n  );\n\n  const disconnect = useCallback(async () => {\n    setState((state) => ({\n      ...state,\n      currentAccount: undefined,\n      currentProvider: defaultProvider,\n      currentChain: defaultChain,\n    }));\n\n    if (autoConnect) {\n      localStorage.removeItem(\"lastUsedConnector\");\n    }\n\n    if (!connectorRef.current) return;\n    connectorRef.current.off(\"change\", handleConnectorChange);\n\n    try {\n      await connectorRef.current.disconnect();\n    } catch {}\n    connectorRef.current = undefined;\n  }, [\n    autoConnect,\n    setState,\n    connectorRef,\n    handleConnectorChange,\n    defaultProvider,\n    defaultChain,\n  ]);\n\n  useEffect(() => {\n    async function tryAutoConnect(connectors: Connector[]) {\n      const lastConnectedConnectorId =\n        localStorage.getItem(\"lastUsedConnector\");\n      if (lastConnectedConnectorId === null) {\n        return;\n      }\n\n      const lastConnectedConnector = connectors.find(\n        (connector) => connector.id === lastConnectedConnectorId,\n      );\n      if (lastConnectedConnector === undefined) {\n        return;\n      }\n\n      try {\n        if (!(await lastConnectedConnector.ready())) {\n          // Not authorized anymore.\n          return;\n        }\n\n        connect({ connector: lastConnectedConnector });\n      } catch {\n        // no-op\n      }\n    }\n\n    if (autoConnect && !connectorRef.current) {\n      tryAutoConnect(withMobileConnector(connectors));\n    }\n    // Dependencies intentionally omitted since we only want\n    // this executed once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    account: state.currentAccount,\n    provider: state.currentProvider,\n    chain: state.currentChain,\n    connector: connectorRef.current,\n    explorer,\n    connect,\n    disconnect,\n    connectors,\n    chains,\n  };\n}\n\n/** Arguments for `StarknetProvider`. */\nexport interface StarknetProviderProps {\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Provider to use. */\n  provider: ChainProviderFactory;\n  /** List of connectors to use. */\n  connectors?: Connector[];\n  /** Explorer to use. */\n  explorer?: ExplorerFactory;\n  /** Connect the first available connector on page load. */\n  autoConnect?: boolean;\n  /** React-query client to use. */\n  queryClient?: QueryClient;\n  /** Application. */\n  children?: React.ReactNode;\n}\n\n/** Root Starknet context provider. */\nexport function StarknetProvider({\n  chains,\n  provider,\n  connectors,\n  explorer,\n  autoConnect,\n  queryClient,\n  children,\n}: StarknetProviderProps): JSX.Element {\n  const { account, ...state } = useStarknetManager({\n    chains,\n    provider,\n    explorer,\n    connectors,\n    autoConnect,\n  });\n\n  return (\n    <QueryClientProvider client={queryClient ?? defaultQueryClient}>\n      <StarknetContext.Provider value={state}>\n        <AccountProvider account={account}>{children}</AccountProvider>\n      </StarknetContext.Provider>\n    </QueryClientProvider>\n  );\n}\n\nfunction providerForChain(\n  chain: Chain,\n  factory: ChainProviderFactory,\n): { chain: Chain; provider: ProviderInterface } {\n  const provider = factory(chain);\n  if (provider) {\n    return { chain, provider };\n  }\n\n  throw new Error(`No provider found for chain ${chain.name}`);\n}\n\nexport function starknetChainId(\n  chainId: bigint,\n): constants.StarknetChainId | undefined {\n  switch (chainId) {\n    case mainnet.id:\n      return constants.StarknetChainId.SN_MAIN;\n    case goerli.id:\n      return constants.StarknetChainId.SN_GOERLI;\n    case sepolia.id:\n      return constants.StarknetChainId.SN_SEPOLIA;\n    default:\n      return undefined;\n  }\n}\n", "import React, { useContext } from \"react\";\n\nimport { AccountInterface } from \"starknet\";\n\nconst AccountContext = React.createContext<AccountInterface | undefined>(\n  undefined,\n);\n\nexport function useStarknetAccount() {\n  const account = useContext(AccountContext);\n  return { account };\n}\n\nexport function AccountProvider({\n  account,\n  children,\n}: {\n  account?: AccountInterface;\n  children: React.ReactNode;\n}) {\n  return (\n    <AccountContext.Provider value={account}>\n      {children}\n    </AccountContext.Provider>\n  );\n}\n", "import React from \"react\";\n\nimport { StarknetProvider, StarknetProviderProps } from \"./starknet\";\n\nexport { starknetChainId } from \"./starknet\";\nexport { AccountProvider as OverrideAccount } from \"./account\";\n\nexport type StarknetConfigProps = StarknetProviderProps;\n\nexport function StarknetConfig({ children, ...config }: StarknetConfigProps) {\n  return <StarknetProvider {...config}>{children}</StarknetProvider>;\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the StarkCompassExplorer class that extends Explorer\nexport class StarkCompassExplorer implements Explorer {\n  public name = \"Stark Compass\";\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"starkCompass\"]?.toString() ?? \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    return `${this.link}/blocks/${hashOrNumber.hash ?? hashOrNumber.number}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/transactions/${hash}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contracts/${address}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/classes/${hash}`;\n  }\n}\n\n// Define the starkcompass factory function\nexport const starkcompass: ExplorerFactory<StarkCompassExplorer> = (\n  chain: Chain,\n) => {\n  return new StarkCompassExplorer(chain);\n};\n", "import { Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the StarkscanExplorer class that extends Explorer\nexport class StarkscanExplorer implements Explorer {\n  public name = \"Starkscan\";\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"starkscan\"]?.toString() ?? \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    return `${this.link}/block/${hashOrNumber.hash ?? hashOrNumber.number}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/tx/${hash}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contract/${address}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/class/${hash}`;\n  }\n}\n\n// Define the starkscan factory function\nexport const starkscan: ExplorerFactory<StarkscanExplorer> = (chain: Chain) => {\n  return new StarkscanExplorer(chain);\n};\n", "import { goerli, type Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the ViewblockExplorer class that extends Explorer\nexport class ViewblockExplorer implements Explorer {\n  public name = \"Viewblock\";\n  private chainParam: string;\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"viewblock\"]?.toString() ?? \"\";\n    this.chainParam = chain.id === goerli.id ? \"?network=goerli\" : \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    if (hashOrNumber.hash && hashOrNumber.number === undefined) {\n      throw new Error(\n        `The viewblock explorer doesnt support hashes for blocks. Please provide a hash.`,\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.number}${this.chainParam}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/tx/${hash}${this.chainParam}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contract/${address}${this.chainParam}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/class/${hash}${this.chainParam}`;\n  }\n}\n\n// Define the viewblock factory function\nexport const viewblock: ExplorerFactory<ViewblockExplorer> = (chain: Chain) => {\n  return new ViewblockExplorer(chain);\n};\n", "import { Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the VoyagerExplorer class that extends Explorer\nexport class VoyagerExplorer implements Explorer {\n  public name = \"Voyager\";\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"voyager\"]?.toString() ?? \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    if (hashOrNumber.number !== undefined && hashOrNumber.hash === undefined) {\n      throw new Error(\n        \"The voyager explorer doesn't support numbers for blocks. Please provide a hash.\",\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.hash}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/tx/${hash}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contract/${address}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/class/${hash}`;\n  }\n}\n\n// Define the voyager factory function\nexport const voyager: ExplorerFactory<VoyagerExplorer> = (chain: Chain) => {\n  return new VoyagerExplorer(chain);\n};\n", "import { useCallback, useEffect, useState } from \"react\";\nimport { AccountInterface } from \"starknet\";\n\nimport { Connector } from \"~/connectors\";\nimport { useStarknetAccount } from \"~/context/account\";\n\nimport { useConnect } from \"./useConnect\";\n\n/** Arguments for `useAccount` hook. */\nexport type UseAccountProps = {\n  /** Function to invoke when connected. */\n  onConnect?: (args: {\n    address?: UseAccountResult[\"address\"];\n    connector?: UseAccountResult[\"connector\"];\n  }) => void;\n  /** Function to invoke when disconnected. */\n  onDisconnect?: () => void;\n};\n\n/** Account connection status. */\nexport type AccountStatus =\n  | \"connected\"\n  | \"disconnected\"\n  | \"connecting\"\n  | \"reconnecting\";\n\n/** Value returned from `useAccount`. */\nexport type UseAccountResult = {\n  /** The connected account object. */\n  account?: AccountInterface;\n  /** The address of the connected account. */\n  address?: string;\n  /** The connected connector. */\n  connector?: Connector;\n  /** Connector's chain id */\n  chainId?: bigint;\n  /** True if connecting. */\n  isConnecting?: boolean;\n  /** True if reconnecting. */\n  isReconnecting?: boolean;\n  /** True if connected. */\n  isConnected?: boolean;\n  /** True if disconnected. */\n  isDisconnected?: boolean;\n  /** The connection status. */\n  status: AccountStatus;\n};\n\n/**\n * Hook for accessing the account and its connection status.\n *\n * @remarks\n *\n * This hook is used to access the `AccountInterface` object provided by the\n * currently connected wallet.\n *\n * @example\n * This example shows how to display the wallet connection status and\n * the currently connected wallet address.\n * ```tsx\n * function Component() {\n *   const { account, address, status } = useAccount()\n *\n *   if (status === 'disconnected') return <p>Disconnected</p>\n *   return <p>Account: {address}</p>\n * }\n * ```\n */\nexport function useAccount({\n  onConnect,\n  onDisconnect,\n}: UseAccountProps = {}): UseAccountResult {\n  const { account: connectedAccount } = useStarknetAccount();\n  const { connectors } = useConnect();\n  const [state, setState] = useState<UseAccountResult>({\n    status: \"disconnected\",\n  });\n\n  const refreshState = useCallback(async () => {\n    if (!connectedAccount) {\n      if (!state.isDisconnected && onDisconnect !== undefined) {\n        onDisconnect();\n      }\n      return setState({\n        status: \"disconnected\",\n        isDisconnected: true,\n        isConnected: false,\n        isConnecting: false,\n        isReconnecting: false,\n      });\n    }\n\n    for (const connector of connectors) {\n      if (!connector.available()) continue;\n\n      // If the connector is not authorized, `.account()` will throw.\n      let connAccount;\n      try {\n        connAccount = await connector.account();\n      } catch {}\n\n      if (connAccount && connAccount?.address === connectedAccount.address) {\n        if (state.isDisconnected && onConnect !== undefined) {\n          onConnect({ address: connectedAccount.address, connector });\n        }\n\n        return setState({\n          connector,\n          chainId: await connector.chainId(),\n          account: connectedAccount,\n          address: connectedAccount.address,\n          status: \"connected\",\n          isConnected: true,\n          isConnecting: false,\n          isDisconnected: false,\n          isReconnecting: false,\n        });\n      }\n    }\n\n    // If we get here, we're not connected to any connector.\n    // This can happen if it's an arcade account.\n    setState({\n      connector: undefined,\n      chainId: undefined,\n      account: connectedAccount,\n      address: connectedAccount.address,\n      status: \"connected\",\n      isConnected: true,\n      isConnecting: false,\n      isDisconnected: false,\n      isReconnecting: false,\n    });\n  }, [\n    setState,\n    connectedAccount,\n    connectors,\n    onConnect,\n    onDisconnect,\n    state.isDisconnected,\n  ]);\n\n  useEffect(() => {\n    refreshState();\n  }, [refreshState]);\n\n  return state;\n}\n", "import { useStarknet } from \"~/context/starknet\";\n\nimport { useCallback } from \"react\";\nimport { Connector } from \"~/connectors/base\";\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nexport type ConnectVariables = { connector?: Connector };\n\ntype MutationResult = UseMutationResult<void, unknown, ConnectVariables>;\n\nexport type UseConnectProps = UseMutationProps<void, unknown, ConnectVariables>;\n\n/** Value returned from `useConnect`. */\nexport type UseConnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Current connector. */\n  connector?: Connector;\n  /** Connectors available for the current chain. */\n  connectors: Connector[];\n  /** Connector waiting approval for connection. */\n  pendingConnector?: Connector;\n  /** Connect to a new connector. */\n  connect: (args?: ConnectVariables) => void;\n  /** Connect to a new connector. */\n  connectAsync: (args?: ConnectVariables) => Promise<void>;\n};\n\n/**\n * Hook for connecting to a StarkNet wallet.\n *\n * @remarks\n *\n * Use this to implement a \"connect wallet\" component.\n *\n * @example\n * This example shows how to connect a wallet.\n * ```tsx\n * function Component() {\n *   const { connect, connectors } = useConnect();\n *   return (\n *     <ul>\n *     {connectors.map((connector) => (\n *       <li key={connector.id}>\n *         <button onClick={() => connect({ connector })}>\n *           {connector.name}\n *         </button>\n *       </li>\n *     ))}\n *     </ul>\n *   )\n * }\n * ```\n */\nexport function useConnect(props: UseConnectProps = {}): UseConnectResult {\n  const { connector, connectors, connect: connect_, chain } = useStarknet();\n\n  const { mutate, mutateAsync, variables, ...result } = useMutation({\n    mutationKey: [{ entity: \"connect\", chainId: chain.name }],\n    mutationFn: connect_,\n    ...props,\n  });\n\n  const connect = useCallback(\n    (args?: ConnectVariables) => mutate(args ?? { connector }),\n    [mutate, connector],\n  );\n\n  const connectAsync = useCallback(\n    (args?: ConnectVariables) => mutateAsync(args ?? { connector }),\n    [mutateAsync, connector],\n  );\n\n  return {\n    connector,\n    connectors,\n    pendingConnector: variables?.connector,\n    connect,\n    connectAsync,\n    variables,\n    ...result,\n  };\n}\n", "import {\n  QueryKey,\n  UseMutationOptions as UseMutationOptions_,\n  UseMutationResult as UseMutationResult_,\n  UseQueryOptions as UseQueryOptions_,\n  UseQueryResult as UseQueryResult_,\n  useMutation as useMutation_,\n  useQuery as useQuery_,\n} from \"@tanstack/react-query\";\n\nexport type UseQueryProps<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Pick<\n  UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n  \"enabled\" | \"refetchInterval\" | \"retry\" | \"retryDelay\"\n>;\n\nexport type UseQueryResult<TData, TError> = Pick<\n  UseQueryResult_<TData, TError>,\n  | \"data\"\n  | \"error\"\n  | \"status\"\n  | \"isSuccess\"\n  | \"isError\"\n  | \"isPending\"\n  | \"fetchStatus\"\n  | \"isFetching\"\n  | \"isLoading\"\n  | \"refetch\"\n>;\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  args: UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const base = useQuery_(args);\n\n  return {\n    data: base.data,\n    error: base.error,\n    status: base.status,\n    isSuccess: base.isSuccess,\n    isError: base.isError,\n    isPending: base.isPending,\n    fetchStatus: base.fetchStatus,\n    isFetching: base.isFetching,\n    isLoading: base.isLoading,\n    refetch: base.refetch,\n  };\n}\nexport type UseMutationProps<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationOptions_<TData, TError, TVariables, TContext>,\n  \"onSuccess\" | \"onError\" | \"onMutate\" | \"onSettled\"\n>;\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationResult_<TData, TError, TVariables, TContext>,\n  | \"data\"\n  | \"error\"\n  | \"isError\"\n  | \"isIdle\"\n  | \"isPending\"\n  | \"isPaused\"\n  | \"isSuccess\"\n  | \"reset\"\n  | \"mutate\"\n  | \"mutateAsync\"\n  | \"status\"\n  | \"variables\"\n>;\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = unknown,\n  TContext = unknown,\n>(\n  args: UseMutationOptions_<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const base = useMutation_(args);\n\n  return {\n    data: base.data,\n    error: base.error,\n    reset: base.reset,\n    isError: base.isError,\n    isIdle: base.isIdle,\n    isPending: base.isPending,\n    isSuccess: base.isSuccess,\n    isPaused: base.isPaused,\n    mutate: base.mutate,\n    mutateAsync: base.mutateAsync,\n    status: base.status,\n    variables: base.variables,\n  };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  BlockNumber,\n  BlockTag,\n  CallData,\n  ContractInterface,\n  num,\n  shortString,\n  uint256,\n} from \"starknet\";\nimport { z } from \"zod\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useContract } from \"./useContract\";\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\nimport { useNetwork } from \"./useNetwork\";\n\nconst DEFAULT_FETCH_INTERVAL = 5_000;\n\nexport type Balance = {\n  decimals: number;\n  symbol: string;\n  formatted: string;\n  value: bigint;\n};\n\nexport type UseBalanceProps = UseQueryProps<\n  Balance,\n  Error,\n  Balance,\n  ReturnType<typeof queryKey>\n> & {\n  /** The contract's address. Defaults to the native currency. */\n  token?: string;\n  /** The address to fetch balance for. */\n  address?: string;\n  /** Whether to watch for changes. */\n  watch?: boolean;\n  /** Block identifier used when performing call. */\n  blockIdentifier?: BlockNumber;\n};\n\nexport type UseBalanceResult = UseQueryResult<Balance, Error>;\n\nexport function useBalance({\n  token,\n  address,\n  blockIdentifier = BlockTag.latest,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseBalanceProps) {\n  const { chain } = useNetwork();\n  const { contract } = useContract({\n    abi: balanceABIFragment,\n    address: token ?? chain.nativeCurrency.address,\n  });\n\n  const queryKey_ = useMemo(\n    () => queryKey({ chain, contract, token, address, blockIdentifier }),\n    [chain, contract, token, address, blockIdentifier],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && address),\n    [enabled_, contract, address],\n  );\n\n  const refetchInterval =\n    refetchInterval_ ??\n    (blockIdentifier === BlockTag.pending && watch\n      ? DEFAULT_FETCH_INTERVAL\n      : undefined);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    enabled,\n    queryKey: queryKey_,\n    queryFn: queryFn({ chain, contract, token, address, blockIdentifier }),\n    refetchInterval,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  contract,\n  token,\n  address,\n  blockIdentifier,\n}: {\n  chain: Chain;\n  contract?: ContractInterface;\n  token?: string;\n  address?: string;\n  blockIdentifier?: BlockNumber;\n}) {\n  return [\n    {\n      entity: \"balance\",\n      chainId: chain?.name,\n      contract,\n      token,\n      address,\n      blockIdentifier,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  chain,\n  token,\n  address,\n  contract,\n  blockIdentifier,\n}: {\n  chain: Chain;\n  token?: string;\n  address?: string;\n  contract?: ContractInterface;\n  blockIdentifier?: BlockNumber;\n}) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n    if (!contract) throw new Error(\"contract is required\");\n\n    const callArgs = { blockIdentifier };\n\n    let symbolPromise = Promise.resolve(chain.nativeCurrency.symbol);\n    if (token) {\n      symbolPromise = contract.call(\"symbol\", [], callArgs).then((result) => {\n        const s = symbolSchema.parse(result).symbol;\n        return shortString.decodeShortString(num.toHex(s));\n      });\n    }\n\n    let decimalsPromise = Promise.resolve(chain.nativeCurrency.decimals);\n    if (token) {\n      decimalsPromise = contract\n        .call(\"decimals\", [], callArgs)\n        .then((result) => {\n          return Number(decimalsSchema.parse(result).decimals);\n        });\n    }\n\n    const balanceOfPromise = contract\n      .call(\"balanceOf\", CallData.compile({ address }), callArgs)\n      .then((result) => {\n        return uint256.uint256ToBN(balanceSchema.parse(result).balance);\n      });\n\n    const [balanceOf, decimals, symbol] = await Promise.all([\n      balanceOfPromise,\n      decimalsPromise,\n      symbolPromise,\n    ]);\n\n    const formatted = formatUnits(balanceOf, decimals);\n\n    return {\n      value: balanceOf,\n      decimals,\n      symbol,\n      formatted,\n    };\n  };\n}\n\nconst uint256Schema = z.object({\n  low: z.bigint(),\n  high: z.bigint(),\n});\n\nconst balanceSchema = z.object({\n  balance: uint256Schema,\n});\n\nconst decimalsSchema = z.object({\n  decimals: z.bigint(),\n});\n\nconst symbolSchema = z.object({\n  symbol: z.bigint(),\n});\n\nconst balanceABIFragment = [\n  {\n    members: [\n      {\n        name: \"low\",\n        offset: 0,\n        type: \"felt\",\n      },\n      {\n        name: \"high\",\n        offset: 1,\n        type: \"felt\",\n      },\n    ],\n    name: \"Uint256\",\n    size: 2,\n    type: \"struct\",\n  },\n  {\n    name: \"balanceOf\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"account\",\n        type: \"felt\",\n      },\n    ],\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"Uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        name: \"symbol\",\n        type: \"felt\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        name: \"decimals\",\n        type: \"felt\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\n/*\nMIT License\n\nCopyright (c) 2023-present weth, LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nhttps://github.com/wevm/viem/blob/main/src/utils/unit/formatUnits.ts\n*/\n\n/**\n *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..\n *\n * - Docs: https://viem.sh/docs/utilities/formatUnits\n *\n * formatUnits(420000000000n, 9)\n * // '420'\n */\nfunction formatUnits(value: bigint, decimals: number) {\n  let display = value.toString();\n\n  const negative = display.startsWith(\"-\");\n  if (negative) display = display.slice(1);\n\n  display = display.padStart(decimals, \"0\");\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ];\n  fraction = fraction.replace(/(0+)$/, \"\");\n  return `${negative ? \"-\" : \"\"}${integer || \"0\"}${\n    fraction ? `.${fraction}` : \"\"\n  }`;\n}\n", "import { useMemo } from \"react\";\nimport { Abi, Contract, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Arguments for `useContract`. */\nexport interface UseContractArgs {\n  /** The contract abi. */\n  abi?: Abi;\n  /** The contract address. */\n  address?: string;\n  /** The provider, by default it will be the current one. */\n  provider?: ProviderInterface | null;\n}\n\n/** Value returned from `useContract`. */\nexport interface UseContractResult {\n  /** The contract. */\n  contract?: Contract;\n}\n\n/**\n * Hook to bind a `Contract` instance.\n *\n * @remarks\n *\n * The returned contract is a starknet.js `Contract` object.\n *\n * @example\n * This example creates a new contract from its address and abi.\n * ```tsx\n * function Component() {\n *   const { contract } = useContract({\n *     address: ethAddress,\n *     abi: compiledErc20.abi\n *   })\n *\n *   return <span>{contract.address}</span>\n * }\n * ```\n */\nexport function useContract({\n  abi,\n  address,\n  provider: providedProvider,\n}: UseContractArgs): UseContractResult {\n  const { provider: currentProvider } = useStarknet();\n\n  const contract = useMemo(() => {\n    const provider = providedProvider ? providedProvider : currentProvider;\n    if (abi && address && provider) {\n      return new Contract(abi, address, provider);\n    }\n    return undefined;\n  }, [abi, address, providedProvider, currentProvider]);\n\n  return { contract };\n}\n", "import { QueryKey, useQueryClient } from \"@tanstack/react-query\";\nimport { useEffect, useState } from \"react\";\nimport { useBlockNumber } from \"./useBlockNumber\";\n\n/**\n * Invalidate the given query on every new block.\n */\nexport function useInvalidateOnBlock({\n  enabled = true,\n  queryKey,\n}: {\n  enabled?: boolean;\n  queryKey: QueryKey;\n}) {\n  const queryClient = useQueryClient();\n\n  const [prevBlockNumber, setPrevBlockNumber] = useState<number | undefined>();\n\n  const { data: blockNumber } = useBlockNumber({\n    enabled,\n  });\n\n  useEffect(() => {\n    if (!prevBlockNumber) {\n      return setPrevBlockNumber(blockNumber);\n    }\n\n    if (blockNumber !== prevBlockNumber) {\n      queryClient.invalidateQueries({ queryKey }, { cancelRefetch: false });\n      return setPrevBlockNumber(blockNumber);\n    }\n  }, [blockNumber, prevBlockNumber]);\n}\n", "import { BlockNumber, BlockTag, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\n/** Arguments for `useBlockNumber`. */\nexport type UseBlockNumberProps = UseQueryProps<\n  number,\n  Error,\n  number,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlockNumber`. */\nexport type UseBlockNumberResult = UseQueryResult<number, Error>;\n\n/**\n * Hook for fetching the current block number.\n *\n * @remarks\n *\n * Control if and how often data is refreshed with `refetchInterval`.\n *\n * @example\n * This example shows how to fetch the current block only once.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlockNumber({\n *     refetchInterval: false\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Block number: {data}</span>\n * }\n * ```\n *\n * @example\n * This example shows how to fetch the current block every 3 seconds.\n * Use your browser network monitor to verify that the hook is refetching the\n * data.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlockNumber({\n *     refetchInterval: 3000\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Block Number: {data}</span>\n * }\n * ```\n */\nexport function useBlockNumber({\n  blockIdentifier = BlockTag.latest,\n  ...props\n}: UseBlockNumberProps = {}): UseBlockNumberResult {\n  const { provider } = useStarknet();\n\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"blockNumber\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: { provider: ProviderInterface; blockIdentifier: BlockNumber }) {\n  return async function () {\n    const block = await provider.getBlock(blockIdentifier);\n    return block.block_number;\n  };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Value returned from `useNetwork`. */\nexport type UseNetworkResult = {\n  /** The current chain. */\n  chain: Chain;\n  /** List of supported chains. */\n  chains: Chain[];\n};\n\n/**\n * Hook for accessing the current connected chain.\n *\n * @remarks\n *\n * The network object contains information about the\n * network.\n *\n * @example\n * This example shows how to display the current network name.\n * ```tsx\n * function Component() {\n *   const { chain } = useNetwork()\n *\n *   return <span>{chain.name}</span>\n * }\n */\nexport function useNetwork(): UseNetworkResult {\n  const { chain, chains } = useStarknet();\n  return { chain, chains };\n}\n", "import {\n  BlockNumber,\n  BlockTag,\n  GetBlockResponse,\n  ProviderInterface,\n} from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\n/** Arguments for `useBlock`. */\nexport type UseBlockProps = UseQueryProps<\n  GetBlockResponse,\n  Error,\n  GetBlockResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlock`. */\nexport type UseBlockResult = UseQueryResult<GetBlockResponse, Error>;\n\n/**\n * Hook for fetching a block.\n *\n * @remarks\n *\n * Specify which block to fetch with the `blockIdentifier` argument.\n * Control if and how often data is refreshed with `refetchInterval`.\n *\n * @example\n * This example shows how to fetch the latest block only once.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlock({\n *     refetchInterval: false,\n *     blockIdentifier: 'latest'\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Hash: {data.block_hash}</span>\n * }\n * ```\n *\n * @example\n * This example shows how to fetch the pending block every 3 seconds.\n * Use your browser network monitor to verify that the hook is refetching the\n * data.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlock({\n *     refetchInterval: 3000,\n *     blockIdentifier: 'pending'\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Hash: {data.block_hash}</span>\n * }\n * ```\n */\nexport function useBlock({\n  blockIdentifier = BlockTag.latest,\n  ...props\n}: UseBlockProps = {}): UseBlockResult {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"block\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: { provider: ProviderInterface; blockIdentifier: BlockNumber }) {\n  return async function () {\n    return await provider.getBlock(blockIdentifier);\n  };\n}\n", "import { useMemo } from \"react\";\nimport { Abi, CompiledContract, ContractFactory } from \"starknet\";\n\nimport { useAccount } from \"./useAccount\";\n\n/** Arguments for `useContractFactory`. */\nexport interface UseContractFactoryProps {\n  /** The compiled contract. */\n  compiledContract?: CompiledContract;\n  /** The class hash  */\n  classHash: string;\n  /** The contract abi. */\n  abi?: Abi;\n}\n\n/** Value returned from `useContractFactory`. */\nexport interface UseContractFactoryResult {\n  /** The contract factory. */\n  contractFactory?: ContractFactory;\n}\n\n/**\n * Hook to create a `ContractFactory`.\n *\n * @remarks\n *\n * The returned contract factory is a starknet.js `ContractFactory` object.\n *\n * This hook works well with `useDeploy`.\n *\n * @example\n * This example shows how to create a contract factory.\n * ```tsx\n * function Component() {\n *   const { contractFactory } = useContractFactory({\n *     compiledContract: compiledErc20,\n *     classHash: erc20ClassHash,\n *     abi: compiledErc20.abi,\n *   })\n *\n *   return <p>Nothing to see here...</p>\n * }\n * ```\n */\nexport function useContractFactory({\n  compiledContract,\n  classHash,\n  abi,\n}: UseContractFactoryProps): UseContractFactoryResult {\n  const { account } = useAccount();\n\n  const contractFactory = useMemo(() => {\n    if (compiledContract && account && classHash) {\n      return new ContractFactory({\n        compiledContract,\n        classHash,\n        account,\n        abi,\n      });\n    }\n    return undefined;\n  }, [compiledContract, classHash, account, abi]);\n\n  return { contractFactory };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  Abi,\n  ArgsOrCalldata,\n  BlockNumber,\n  BlockTag,\n  Contract,\n  Result,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useContract } from \"./useContract\";\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\nimport { useNetwork } from \"./useNetwork\";\n\nconst DEFAULT_FETCH_INTERVAL = 5_000;\n\ntype ContractReadArgs = {\n  /** The contract's function name. */\n  functionName: string;\n  /** Read arguments. */\n  args?: ArgsOrCalldata;\n  /** Block identifier used when performing call. */\n  blockIdentifier?: BlockNumber;\n  /** Parse arguments before passing to contract. */\n  parseArgs?: boolean;\n  /** Parse result after calling contract. */\n  parseResult?: boolean;\n};\n\n/** Options for `useContractRead`. */\nexport type UseContractReadProps = ContractReadArgs &\n  UseQueryProps<Result, Error, Result, ReturnType<typeof queryKey>> & {\n    /** The target contract's ABI. */\n    abi?: Abi;\n    /** The target contract's address. */\n    address?: string;\n    /** Refresh data at every block. */\n    watch?: boolean;\n  };\n\n/** Value returned from `useContractRead`. */\nexport type UseContractReadResult = UseQueryResult<Result, Error>;\n\n/**\n * Hook to perform a read-only contract call.\n *\n * @remarks\n *\n * The hook only performs a call if the target `abi`, `address`,\n * `functionName`, and `args` are not undefined.\n */\nexport function useContractRead({\n  abi,\n  address,\n  functionName,\n  args,\n  blockIdentifier = BlockTag.latest,\n  parseArgs,\n  parseResult,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseContractReadProps): UseContractReadResult {\n  const { chain } = useNetwork();\n  const { contract } = useContract({ abi, address });\n\n  const queryKey_ = useMemo(\n    () => queryKey({ chain, contract, functionName, args, blockIdentifier }),\n    [chain, contract, functionName, args, blockIdentifier],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && functionName && args),\n    [enabled_, contract, functionName, args],\n  );\n\n  const refetchInterval =\n    refetchInterval_ ??\n    (blockIdentifier === BlockTag.pending && watch\n      ? DEFAULT_FETCH_INTERVAL\n      : undefined);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    enabled,\n    queryKey: queryKey_,\n    queryFn: queryFn({\n      contract,\n      functionName,\n      args,\n      blockIdentifier,\n      parseArgs,\n      parseResult,\n    }),\n    refetchInterval,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n}: { chain?: Chain; contract?: Contract } & ContractReadArgs) {\n  return [\n    {\n      entity: \"readContract\",\n      chainId: chain?.name,\n      contract: contract?.address,\n      functionName,\n      args,\n      blockIdentifier,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n  parseArgs,\n  parseResult,\n}: { contract?: Contract } & ContractReadArgs) {\n  return async function () {\n    if (!contract) throw new Error(\"contract is required\");\n    if (contract.functions[functionName] === undefined) {\n      throw new Error(`function ${functionName} not found in contract`);\n    }\n\n    return contract.call(functionName, args, {\n      parseRequest: parseArgs,\n      parseResponse: parseResult,\n      blockIdentifier,\n    });\n  };\n}\n", "import { useCallback } from \"react\";\nimport {\n  Abi,\n  AccountInterface,\n  Call,\n  InvocationsDetails,\n  InvokeFunctionResponse,\n} from \"starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nimport { useAccount } from \"./useAccount\";\n\n/** Arguments for `useContractWrite`. */\nexport type ContractWriteVariables = {\n  /** List of smart contract calls to execute. */\n  calls?: Call[];\n  /** Contract ABIs for better displaying. */\n  abis?: Abi[];\n  /** Transaction options. */\n  options?: InvocationsDetails;\n};\n\nexport type UseContractWriteProps = ContractWriteVariables &\n  UseMutationProps<InvokeFunctionResponse, Error, ContractWriteVariables>;\n\nexport type MutationResult = UseMutationResult<\n  InvokeFunctionResponse,\n  Error,\n  ContractWriteVariables\n>;\n\nexport type UseContractWriteResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Execute the calls. */\n  write: (args?: ContractWriteVariables) => void;\n  /** Execute the calls. */\n  writeAsync: (\n    args?: ContractWriteVariables,\n  ) => Promise<InvokeFunctionResponse>;\n};\n\n/**\n * Hook to perform a Starknet multicall.\n *\n * @remarks\n *\n * Multicalls are used to submit multiple transactions in a single\n * call to improve user experience.\n */\nexport function useContractWrite({\n  calls,\n  abis,\n  options,\n  ...props\n}: UseContractWriteProps): UseContractWriteResult {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ account, calls, abis, options }),\n    mutationFn: mutationFn({ account }),\n    ...props,\n  });\n\n  const write = useCallback(\n    (args?: ContractWriteVariables) => {\n      return mutate({\n        ...(args ?? {\n          calls,\n          abis,\n          options,\n        }),\n      });\n    },\n    [mutate, calls, abis, options],\n  );\n\n  const writeAsync = useCallback(\n    (args?: ContractWriteVariables) => {\n      return mutateAsync({\n        ...(args ?? {\n          calls,\n          abis,\n          options,\n        }),\n      });\n    },\n    [mutateAsync, calls, abis, options],\n  );\n\n  return {\n    write,\n    writeAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey({\n  account,\n  calls,\n  abis,\n  options,\n}: {\n  account?: AccountInterface;\n  calls?: Call[];\n  abis?: Abi[];\n  options?: InvocationsDetails;\n}) {\n  return [{ entity: \"contractWrite\", account, calls, abis, options }] as const;\n}\n\nfunction mutationFn({\n  account,\n}: {\n  account?: AccountInterface;\n}) {\n  return async function ({ calls, abis, options }: ContractWriteVariables) {\n    if (!account) throw new Error(\"account is required\");\n    if (!calls || calls.length === 0) throw new Error(\"calls are required\");\n    return await account?.execute(calls, abis, options);\n  };\n}\n", "import { useStarknet } from \"~/context/starknet\";\nimport { Explorer } from \"~/explorers\";\n\nexport function useExplorer(): Explorer {\n  const { explorer, chain } = useStarknet();\n  if (!explorer)\n    throw Error(\"Explorer is undefined. Try adding it to StarknetConfig.\");\n  const explorerInstance = explorer(chain);\n  if (!explorerInstance) throw Error(\"Explorer Instance is undefined\");\n  return explorerInstance;\n}\n", "import {\n  AccountInterface,\n  BigNumberish,\n  DeployContractResponse,\n  InvocationsDetails,\n  RawArgs,\n} from \"starknet\";\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nimport { useAccount } from \"./useAccount\";\n\nexport type DeployAccountVariables = {\n  /** The class hash of the contract to deploy. */\n  classHash?: string;\n  /** The constructor arguments. */\n  constructorCalldata?: RawArgs;\n  /** Address salt. */\n  addressSalt?: BigNumberish;\n  /** Contract address. */\n  contractAddress?: string;\n  /** Transaction options. */\n  options?: InvocationsDetails;\n};\n\nexport type UseDeployAccountProps = DeployAccountVariables &\n  UseMutationProps<DeployContractResponse, Error, DeployAccountVariables>;\n\ntype MutationResult = UseMutationResult<\n  DeployContractResponse,\n  Error,\n  DeployAccountVariables\n>;\n\nexport type UseDeployAccountResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Deploy account. */\n  deployAccount: MutationResult[\"mutate\"];\n\n  /** Deploy account. */\n  deployAccountAsync: MutationResult[\"mutateAsync\"];\n};\n\n/**\n * Hook for deploying a contract.\n *\n * @remarks\n *\n * This hook deploys a new contract from the currently connected account.\n */\nexport function useDeployAccount({\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n  ...props\n}: UseDeployAccountProps): UseDeployAccountResult {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    mutationFn: mutationFn({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    ...props,\n  });\n\n  return {\n    deployAccount: mutate,\n    deployAccountAsync: mutateAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey(\n  props: { account?: AccountInterface } & Partial<DeployAccountVariables>,\n) {\n  return [{ entity: \"deployAccount\", ...props }] as const;\n}\n\nfunction mutationFn({\n  account,\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n}: { account?: AccountInterface } & Partial<DeployAccountVariables>) {\n  return async function () {\n    if (!account) throw new Error(\"account is required\");\n    if (!classHash) throw new Error(\"classHash is required\");\n    return await account.deployAccount(\n      { classHash, constructorCalldata, addressSalt, contractAddress },\n      options,\n    );\n  };\n}\n", "import { useStarknet } from \"~/context/starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\ntype MutationResult = UseMutationResult<void, unknown, void>;\n\nexport type UseDisconnectProps = UseMutationProps<void, unknown, void>;\n\n/** Value returned from `useDisconnect`. */\nexport type UseDisconnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Disconnect wallet. */\n  disconnect: MutationResult[\"mutate\"];\n  /** Disconnect wallet. */\n  disconnectAsync: MutationResult[\"mutateAsync\"];\n};\n\nexport function useDisconnect(\n  props: UseDisconnectProps = {},\n): UseDisconnectResult {\n  const { disconnect, chain } = useStarknet();\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: [{ entity: \"disconnect\", chainId: chain.name }],\n    mutationFn: disconnect,\n    ...props,\n  });\n\n  return {\n    disconnect: mutate,\n    disconnectAsync: mutateAsync,\n    ...result,\n  };\n}\n", "import { ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Value returned from `useProvider`. */\nexport interface UseProviderResult {\n  /** The current provider. */\n  provider: ProviderInterface;\n}\n\n/**\n * Hook for accessing the current provider.\n *\n * @remarks\n *\n * Use this hook to access the current provider object\n * implementing starknet.js `ProviderInterface`.\n *\n * @example\n * This example shows how to access the current provider.\n * ```tsx\n * function Component() {\n *   const { provider } = useProvider()\n * }\n * ```\n */\nexport function useProvider(): UseProviderResult {\n  const { provider } = useStarknet();\n  return { provider };\n}\n", "import { useCallback } from \"react\";\nimport { AccountInterface, Signature, TypedData } from \"starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\nimport { useAccount } from \"./useAccount\";\n\nexport type SignTypedDataVariables = Partial<TypedData>;\n\ntype MutationResult = UseMutationResult<\n  Signature,\n  Error,\n  SignTypedDataVariables\n>;\n\n/** Arguments for `useSignTypedData` hook. */\nexport type UseSignTypedDataProps = Partial<TypedData> &\n  UseMutationProps<Signature, Error, SignTypedDataVariables>;\n\n/** Value returned by `useSignTypedData` hook. */\nexport type UseSignTypedDataResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  signTypedData: (args?: SignTypedDataVariables) => void;\n  signTypedDataAsync: (args?: SignTypedDataVariables) => Promise<Signature>;\n};\n\nexport function useSignTypedData({\n  domain,\n  types,\n  message,\n  primaryType,\n  ...props\n}: UseSignTypedDataProps): UseSignTypedDataResult {\n  const { account } = useAccount();\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ domain, types, message, primaryType }),\n    mutationFn: mutateFn({ account }),\n    ...props,\n  });\n\n  const signTypedData = useCallback(\n    (args?: SignTypedDataVariables) =>\n      mutate(\n        args ?? {\n          domain,\n          types,\n          message,\n          primaryType,\n        },\n      ),\n    [mutate, domain, types, message, primaryType],\n  );\n\n  const signTypedDataAsync = useCallback(\n    (args?: SignTypedDataVariables) =>\n      mutateAsync(\n        args ?? {\n          domain,\n          types,\n          message,\n          primaryType,\n        },\n      ),\n    [mutateAsync, domain, types, message, primaryType],\n  );\n\n  return {\n    signTypedData,\n    signTypedDataAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey({\n  domain,\n  types,\n  message,\n  primaryType,\n}: Partial<TypedData>) {\n  return [\n    {\n      entity: \"signTypedData\",\n      domain,\n      types,\n      message,\n      primaryType,\n    },\n  ] as const;\n}\n\nfunction mutateFn({ account }: { account?: AccountInterface }) {\n  return function ({\n    domain,\n    types,\n    message,\n    primaryType,\n  }: SignTypedDataVariables): Promise<Signature> {\n    if (!account) throw new Error(\"account is required\");\n    if (!domain) throw new Error(\"domain is required\");\n    if (!types) throw new Error(\"types is required\");\n    if (!message) throw new Error(\"message is required\");\n    if (!primaryType) throw new Error(\"primaryType is required\");\n    return account.signMessage({ domain, types, message, primaryType });\n  };\n}\n", "import { useMemo } from \"react\";\nimport { CallData, Provider, ProviderInterface, starknetId } from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\nimport { useNetwork } from \"./useNetwork\";\n\nexport type UseStarkAddressProps = UseQueryProps<\n  string,\n  Error,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Stark name. */\n  name?: string;\n  /** Naming contract to use . */\n  contract?: string;\n};\n\nexport type UseStarkAddressResult = UseQueryResult<string, Error>;\n\n/**\n * Hook to get the address associated to a stark name.\n *\n * @remarks\n *\n * This hook fetches the address of the specified stark name\n * It defaults to the starknetID contract but a different contract can be targetted by specifying its address\n * If stark name does not have an associated address, it will return \"0x0\"\n *\n * @example\n * This example shows how to get the address associated to a stark name\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching address...</span>\n *   return <span>address: {data}</span>\n * }\n * ```\n */\nexport function useStarkAddress({\n  name,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: UseStarkAddressProps): UseStarkAddressResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n\n  const enabled = useMemo(() => Boolean(enabled_ && name), [enabled_, name]);\n\n  return useQuery({\n    queryKey: queryKey({ name, contract, network: chain.network }),\n    queryFn: queryFn({ name, contract, provider, network: chain.network }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  name,\n  contract,\n  network,\n}: {\n  name?: string;\n  contract?: string;\n  network?: string;\n}) {\n  return [{ entity: \"addressFromStarkName\", name, contract, network }] as const;\n}\n\nfunction queryFn({\n  name,\n  contract,\n  provider,\n  network,\n}: UseStarkAddressProps & { provider: ProviderInterface } & {\n  network: string;\n}) {\n  return async function () {\n    if (!name) throw new Error(\"name is required\");\n\n    const namingContract = contract ?? StarknetIdNamingContract[network];\n    const p = new Provider(provider);\n    const encodedDomain = encodeDomain(name);\n    const result = await p.callContract({\n      contractAddress: namingContract as string,\n      entrypoint: \"domain_to_address\",\n      calldata: CallData.compile({ domain: encodedDomain, hint: [] }),\n    });\n\n    // StarknetID returns 0x0 if no name is found, but that can be dangerous\n    // since we can't expect the user to know that 0x0 is not a valid address.\n    if (BigInt(result.result[0] as string) === BigInt(0))\n      throw new Error(\"Address not found\");\n\n    return result.result[0] as string;\n  };\n}\n\nconst StarknetIdNamingContract: Record<string, string> = {\n  goerli: \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\",\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n};\n\nconst encodeDomain = (domain: string): string[] => {\n  if (!domain) return [\"0\"];\n\n  const encoded = [];\n  for (const subdomain of domain.replace(\".stark\", \"\").split(\".\"))\n    encoded.push(starknetId.useEncoded(subdomain).toString(10));\n  return encoded;\n};\n", "import { useMemo } from \"react\";\nimport {\n  Call,\n  CallData,\n  Provider,\n  ProviderInterface,\n  starknetId,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\nimport { useNetwork } from \"./useNetwork\";\n\n/** Arguments for `useStarkName` hook. */\nexport type StarkNameArgs = UseQueryProps<\n  string,\n  unknown,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: string;\n  /** Naming contract to use . */\n  contract?: string;\n};\n\n/** Value returned by `useStarkName` hook. */\nexport type StarkNameResult = UseQueryResult<string, unknown>;\n\n/**\n * Hook for fetching Stark name for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address.\n * It defaults to the starknet.id contract but a different contract can be\n * targetted by specifying its contract address\n * If address does not have a stark name, it will return \"stark\"\n *\n * @example\n * This example shows how to get the stark name of an address using the default\n * Starknet.id contract\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkName({ address })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching name...</span>\n *   return <span>StarkName: {data}</span>\n * }\n * ```\n *\n *  @example\n * This example shows how to get the stark name of an address specifying a\n * different contract address\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkName({ address, contract: '0x1234' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching name...</span>\n *   return <span>StarkName: {data}</span>\n * }\n * ```\n */\nexport function useStarkName({\n  address,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: StarkNameArgs): StarkNameResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address],\n  );\n\n  return useQuery({\n    queryKey: queryKey({ address, contract, network: chain.network }),\n    queryFn: queryFn({ address, contract, provider, network: chain.network }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  contract,\n  network,\n}: {\n  address?: string;\n  contract?: string;\n  network?: string;\n}) {\n  return [{ entity: \"starkName\", address, contract, network }] as const;\n}\n\nfunction queryFn({\n  address,\n  contract,\n  provider,\n  network,\n}: StarkNameArgs & { provider: ProviderInterface } & {\n  network: string;\n}) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n\n    const namingContract = contract ?? StarknetIdNamingContract[network];\n    const p = new Provider(provider);\n    try {\n      // remove fallback when starknetid naming contract is updated on mainnet\n      const calldata: Call = {\n        contractAddress: namingContract as string,\n        entrypoint: \"address_to_domain\",\n        calldata: CallData.compile({\n          address: address,\n          hint: [],\n        }),\n      };\n      const fallbackCalldata: Call = {\n        contractAddress: namingContract as string,\n        entrypoint: \"address_to_domain\",\n        calldata: CallData.compile({\n          address: address,\n        }),\n      };\n      const hexDomain = await executeWithFallback(\n        p,\n        calldata,\n        fallbackCalldata,\n      );\n      const decimalDomain = hexDomain.result\n        .map((element) => BigInt(element))\n        .slice(1);\n      const stringDomain = starknetId.useDecoded(decimalDomain);\n      if (!stringDomain) {\n        throw new Error(\"Could not get stark name\");\n      }\n      return stringDomain;\n    } catch (e) {\n      throw new Error(\"Could not get stark name\");\n    }\n  };\n}\n\nconst executeWithFallback = async (\n  provider: ProviderInterface,\n  initialCall: Call,\n  fallbackCall: Call,\n) => {\n  try {\n    // Attempt the initial call with the hint parameter\n    return await provider.callContract(initialCall);\n  } catch (initialError) {\n    // If the initial call fails, try with the fallback calldata without the hint parameter\n    try {\n      return await provider.callContract(fallbackCall);\n    } catch (fallbackError) {\n      throw fallbackError; // Re-throw to handle outside\n    }\n  }\n};\n\nconst StarknetIdNamingContract: Record<string, string> = {\n  goerli: \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\",\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n};\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport { GetTransactionReceiptResponse, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\n\n/** Arguments for the `useWaitForTransaction` hook. */\nexport type UseWaitForTransactionProps = UseQueryProps<\n  GetTransactionReceiptResponse,\n  Error,\n  GetTransactionReceiptResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** The transaction hash. */\n  hash?: string;\n  /** Refresh data at every block. */\n  watch?: boolean;\n};\n\nexport type UseWaitForTransactionResult = UseQueryResult<\n  GetTransactionReceiptResponse,\n  Error\n>;\n\n/**\n * Hook to fetch a single transaction receipt.\n *\n * @remarks\n *\n * This hook keeps a cache of receipts by chain and transaction hash\n * so that you can use the hook freely in your application without worrying\n * about sending duplicate network requests.\n *\n * If you need to refresh the transaction receipt data, set `watch: true` in\n * the props. The hook will periodically refresh the transaction data in the\n * background.\n *\n */\nexport function useWaitForTransaction({\n  hash,\n  watch,\n  enabled: enabled_ = true,\n  ...props\n}: UseWaitForTransactionProps): UseWaitForTransactionResult {\n  const { provider, chain } = useStarknet();\n\n  const queryKey_ = useMemo(() => queryKey({ chain, hash }), [chain, hash]);\n\n  const enabled = useMemo(() => Boolean(enabled_ && hash), [enabled_, hash]);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({ provider, hash }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({ chain, hash }: { chain?: Chain; hash?: string }) {\n  return [\n    { entity: \"transactionReceipt\", chainId: chain?.name, hash },\n  ] as const;\n}\n\nfunction queryFn({\n  provider,\n  hash,\n}: {\n  provider: ProviderInterface;\n  hash?: string;\n}) {\n  return async function () {\n    if (!hash) throw new Error(\"hash is required\");\n\n    return await provider.getTransactionReceipt(hash);\n  };\n}\n", "import { useMemo } from \"react\";\nimport {\n  CairoCustomEnum,\n  ContractInterface,\n  ProviderInterface,\n  RawArgsArray,\n  cairo,\n  hash,\n  shortString,\n  starknetId,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\nimport { useContract } from \"./useContract\";\nimport { useNetwork } from \"./useNetwork\";\n\n/** Arguments for `useStarkProfile` hook. */\nexport type StarkProfileArgs = UseQueryProps<\n  GetStarkprofileResponse,\n  unknown,\n  GetStarkprofileResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: string;\n  /** Get Starknet ID default pfp url if no profile picture is set */\n  useDefaultPfp?: boolean;\n  /** Naming contract to use. */\n  namingContract?: string;\n  /** Identity contract to use. */\n  identityContract?: string;\n};\n\n/** Value returned by `useStarkProfile` hook. */\ntype GetStarkprofileResponse = {\n  name?: string;\n  /** Metadata url of the NFT set as profile picture. */\n  profile?: string;\n  /** Profile picture url. */\n  profilePicture?: string;\n  twitter?: string;\n  github?: string;\n  discord?: string;\n  proofOfPersonhood?: boolean;\n};\nexport type useStarkProfileResult = UseQueryResult<\n  GetStarkprofileResponse,\n  unknown\n>;\n\n/**\n * Hook for fetching Stark profile for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address, profile picture url,\n * social networks ids, and proof of personhood a user has set on its starknetid.\n * It defaults to the starknet.id naming and identity contracts but different contracts can be\n * targetted by specifying their contract addresses\n * If address does not have a stark name, it will return \"stark\"\n *\n * @example\n * This example shows how to get the stark profile of an address using the default\n * Starknet.id contracts\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkProfile({ address })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching stark profile...</span>\n *   return (\n *      <span>name: {data?.name}</span>\n *      <span>Profile picture metadata uri : {data?.profile}</span>\n *      <span>Profile picture uri : {data?.profilePicture}</span>\n *      <span>Discord id: {data?.discord}</span>\n *      <span>Twitter id: {data?.twitter}</span>\n *      <span>Github id: {data?.github}</span>\n *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>\n *    )\n * }\n * ```\n *\n *  @example\n * This example shows how to get the stark profile of an address disabling useDefaultPfp and specifying a\n * different naming and identity contract addresses\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkProfile({ address, useDefaultPfp: false, namingContract: '0x1234', identityContract: '0x5678' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching profile...</span>\n *   return (\n *      <span>name: {data?.name}</span>\n *      <span>Profile picture metadata uri : {data?.profile}</span>\n *      <span>Profile picture uri : {data?.profilePicture}</span>\n *      <span>Discord id: {data?.discord}</span>\n *      <span>Twitter id: {data?.twitter}</span>\n *      <span>Github id: {data?.github}</span>\n *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>\n *    )\n * }\n * ```\n */\nexport function useStarkProfile({\n  address,\n  useDefaultPfp = true,\n  namingContract,\n  identityContract,\n  enabled: enabled_ = true,\n  ...props\n}: StarkProfileArgs): useStarkProfileResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  if (!StarknetIdcontracts[chain.network])\n    throw new Error(\"Network not supported\");\n  const { contract: multicallContract } = useContract({\n    abi: multicallABI,\n    address: (StarknetIdcontracts[chain.network] as any)[\"multicall\"],\n  });\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address],\n  );\n\n  return useQuery({\n    queryKey: queryKey({ address, namingContract, identityContract }),\n    queryFn: queryFn({\n      address,\n      useDefaultPfp,\n      namingContract,\n      provider,\n      network: chain.network,\n      identityContract,\n      multicallContract,\n    }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  namingContract,\n  identityContract,\n}: {\n  address?: string;\n  namingContract?: string;\n  identityContract?: string;\n}) {\n  return [\n    { entity: \"starkprofile\", address, namingContract, identityContract },\n  ] as const;\n}\n\nfunction queryFn({\n  address,\n  useDefaultPfp,\n  namingContract,\n  identityContract,\n  provider,\n  network,\n  multicallContract,\n}: StarkProfileArgs & { provider: ProviderInterface } & { network?: string } & {\n  multicallContract?: ContractInterface;\n}) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n    if (!multicallContract) throw new Error(\"multicallContract is required\");\n    if (!network) throw new Error(\"network is required\");\n\n    const contracts = StarknetIdcontracts[network] as Record<string, string>;\n    const identity = identityContract ?? (contracts[\"identity\"] as string);\n    const naming = namingContract ?? (contracts[\"naming\"] as string);\n\n    const { initialCalldata, fallbackCalldata } = getStarkProfileCalldata(\n      address,\n      naming,\n      identity,\n      contracts,\n    );\n    const data = await executeMulticallWithFallback(\n      multicallContract,\n      \"aggregate\",\n      initialCalldata,\n      fallbackCalldata,\n    );\n\n    if (Array.isArray(data)) {\n      const name =\n        data[0][0] !== BigInt(0)\n          ? starknetId.useDecoded(data[0].slice(1))\n          : undefined;\n      const twitter =\n        data[2][0] !== BigInt(0) ? data[2][0].toString() : undefined;\n      const github =\n        data[3][0] !== BigInt(0) ? data[3][0].toString() : undefined;\n      const discord =\n        data[4][0] !== BigInt(0) ? data[4][0].toString() : undefined;\n      const proofOfPersonhood = data[5][0] === BigInt(1) ? true : false;\n\n      const profile =\n        data.length === 9\n          ? data[8]\n              .slice(1)\n              .map((val: BigInt) =>\n                shortString.decodeShortString(val.toString()),\n              )\n              .join(\"\")\n          : undefined;\n\n      // extract nft_image from profile data\n      const profilePicture = profile\n        ? profile.includes(\"base64\")\n          ? JSON.parse(atob(profile.split(\",\")[1].slice(0, -1))).image\n          : await fetchImageUrl(profile)\n        : useDefaultPfp\n        ? `https://starknet.id/api/identicons/${data[1][0].toString()}`\n        : undefined;\n\n      return {\n        name,\n        twitter,\n        github,\n        discord,\n        proofOfPersonhood,\n        profilePicture,\n        profile,\n      };\n    } else {\n      throw new Error(\"Error while fetching data\");\n    }\n  };\n}\n\nconst hardcoded = (arg: string | number) => {\n  return new CairoCustomEnum({\n    Hardcoded: arg,\n  });\n};\n\nconst reference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    Reference: cairo.tuple(call, pos),\n  });\n};\n\nconst arrayReference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    ArrayReference: cairo.tuple(call, pos),\n  });\n};\n\nconst staticExecution = () => {\n  return new CairoCustomEnum({\n    Static: {},\n  });\n};\n\nconst notEqual = (call: number, pos: number, value: number) => {\n  return new CairoCustomEnum({\n    IfNotEqual: cairo.tuple(call, pos, value),\n  });\n};\n\nconst fetchImageUrl = async (url: string): Promise<string> => {\n  try {\n    const response = await fetch(parseImageUrl(url));\n\n    if (!response.ok) {\n      throw new Error(\"Network response was not ok\");\n    }\n\n    const data = await response.json();\n\n    // Check if the \"image\" key exists and is not null\n    if (data.image) {\n      return parseImageUrl(data.image);\n    } else {\n      return \"Image is not set\";\n    }\n  } catch (error) {\n    console.error(\"There was a problem fetching the image URL:\", error);\n    return \"Error fetching data\";\n  }\n};\n\nconst parseImageUrl = (url: string): string => {\n  return url.startsWith(\"ipfs://\")\n    ? url.replace(\"ipfs://\", \"https://gateway.pinata.cloud/ipfs/\")\n    : url;\n};\n\nconst StarknetIdcontracts: Record<string, Record<string, string>> = {\n  goerli: {\n    naming: \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\",\n    identity:\n      \"0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d\",\n    verifier:\n      \"0x019e5204152a72891bf8cd0bed8f03593fdb29ceacd14fca587be5d9fcf87c0e\",\n    verifier_pop:\n      \"0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106\",\n    verifier_pfp:\n      \"0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n  sepolia: {\n    naming: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n    identity: \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\",\n    verifier:\n      \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\",\n    verifier_pop:\n      \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\",\n    verifier_pfp:\n      \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n  mainnet: {\n    naming: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n    identity:\n      \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\",\n    verifier:\n      \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\",\n    verifier_pop:\n      \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\",\n    verifier_pfp:\n      \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n};\n\nconst executeMulticallWithFallback = async (\n  contract: ContractInterface,\n  functionName: string,\n  initialCalldata: RawArgsArray,\n  fallbackCalldata: RawArgsArray,\n) => {\n  try {\n    // Attempt the initial call with the new hint parameter\n    return await contract.call(functionName, [initialCalldata]);\n  } catch (initialError) {\n    // If the initial call fails, try with the fallback calldata without the hint parameter\n    try {\n      return await contract.call(functionName, [fallbackCalldata]);\n    } catch (fallbackError) {\n      throw fallbackError; // Re-throw to handle outside\n    }\n  }\n};\n\nconst getStarkProfileCalldata = (\n  address: string,\n  namingContract: string,\n  identityContract: string,\n  contracts: Record<string, string>,\n): {\n  initialCalldata: RawArgsArray;\n  fallbackCalldata: RawArgsArray;\n} => {\n  let initialCalldata: RawArgsArray = [];\n  let fallbackCalldata: RawArgsArray = [];\n\n  initialCalldata.push({\n    execution: staticExecution(),\n    to: hardcoded(namingContract),\n    selector: hardcoded(hash.getSelectorFromName(\"address_to_domain\")),\n    calldata: [hardcoded(address), hardcoded(\"0\")],\n  });\n  fallbackCalldata.push({\n    execution: staticExecution(),\n    to: hardcoded(namingContract),\n    selector: hardcoded(hash.getSelectorFromName(\"address_to_domain\")),\n    calldata: [hardcoded(address)],\n  });\n\n  const calls = [\n    {\n      execution: staticExecution(),\n      to: hardcoded(namingContract),\n      selector: hardcoded(hash.getSelectorFromName(\"domain_to_id\")),\n      calldata: [arrayReference(0, 0)],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"twitter\")),\n        hardcoded(contracts[\"verifier\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"github\")),\n        hardcoded(contracts[\"verifier\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"discord\")),\n        hardcoded(contracts[\"verifier\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"proof_of_personhood\")),\n        hardcoded(contracts[\"verifier_pop\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    // PFP\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"nft_pp_contract\")),\n        hardcoded(contracts[\"verifier_pfp\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(\n        hash.getSelectorFromName(\"get_extended_verifier_data\"),\n      ),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"nft_pp_id\")),\n        hardcoded(\"2\"),\n        hardcoded(contracts[\"verifier_pfp\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: notEqual(6, 0, 0),\n      to: reference(6, 0),\n      selector: hardcoded(hash.getSelectorFromName(\"tokenURI\")),\n      calldata: [reference(7, 1), reference(7, 2)],\n    },\n  ];\n  initialCalldata.push(...calls);\n  fallbackCalldata.push(...calls);\n\n  return { initialCalldata, fallbackCalldata };\n};\n\nconst multicallABI = [\n  {\n    type: \"impl\",\n    name: \"ComposableMulticallImpl\",\n    interface_name: \"composable_multicall::IComposableMulticall\",\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::Execution\",\n    variants: [\n      { name: \"Static\", type: \"()\" },\n      {\n        name: \"IfEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n      {\n        name: \"IfNotEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n    ],\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::DynamicFelt\",\n    variants: [\n      { name: \"Hardcoded\", type: \"core::felt252\" },\n      { name: \"Reference\", type: \"(core::integer::u32, core::integer::u32)\" },\n    ],\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::DynamicCalldata\",\n    variants: [\n      { name: \"Hardcoded\", type: \"core::felt252\" },\n      { name: \"Reference\", type: \"(core::integer::u32, core::integer::u32)\" },\n      {\n        name: \"ArrayReference\",\n        type: \"(core::integer::u32, core::integer::u32)\",\n      },\n    ],\n  },\n  {\n    type: \"struct\",\n    name: \"composable_multicall::DynamicCall\",\n    members: [\n      { name: \"execution\", type: \"composable_multicall::Execution\" },\n      { name: \"to\", type: \"composable_multicall::DynamicFelt\" },\n      { name: \"selector\", type: \"composable_multicall::DynamicFelt\" },\n      {\n        name: \"calldata\",\n        type: \"core::array::Array::<composable_multicall::DynamicCalldata>\",\n      },\n    ],\n  },\n  {\n    type: \"struct\",\n    name: \"core::array::Span::<core::felt252>\",\n    members: [\n      { name: \"snapshot\", type: \"@core::array::Array::<core::felt252>\" },\n    ],\n  },\n  {\n    type: \"interface\",\n    name: \"composable_multicall::IComposableMulticall\",\n    items: [\n      {\n        type: \"function\",\n        name: \"aggregate\",\n        inputs: [\n          {\n            name: \"calls\",\n            type: \"core::array::Array::<composable_multicall::DynamicCall>\",\n          },\n        ],\n        outputs: [\n          { type: \"core::array::Array::<core::array::Span::<core::felt252>>\" },\n        ],\n        state_mutability: \"view\",\n      },\n    ],\n  },\n  {\n    type: \"event\",\n    name: \"composable_multicall::contract::ComposableMulticall::Event\",\n    kind: \"enum\",\n    variants: [],\n  },\n];\n", "import { useMemo } from \"react\";\nimport {\n  AccountInterface,\n  Call,\n  EstimateFeeDetails,\n  EstimateFeeResponse,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useAccount } from \"./useAccount\";\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\n\ntype EstimateFeesArgs = {\n  /** List of smart contract calls to estimate. */\n  calls?: Call[];\n  /** Estimate Fee options. */\n  options?: EstimateFeeDetails;\n};\n\n/** Options for `useEstimateFees`. */\nexport type UseEstimateFeesProps = EstimateFeesArgs &\n  UseQueryProps<\n    EstimateFeeResponse,\n    Error,\n    EstimateFeeResponse,\n    ReturnType<typeof queryKey>\n  > & {\n    /** Refresh data at every block. */\n    watch?: boolean;\n  };\n\n/** Value returned from `useEstimateFees`. */\nexport type UseEstimateFeesResult = UseQueryResult<EstimateFeeResponse, Error>;\n\n/**\n * Hook to estimate fees for smart contract calls.\n *\n * @remarks\n *\n * The hook only performs estimation if the `calls` is not undefined.\n */\nexport function useEstimateFees({\n  calls,\n  options,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseEstimateFeesProps): UseEstimateFeesResult {\n  const { account } = useAccount();\n\n  const queryKey_ = useMemo(\n    () => queryKey({ calls, options }),\n    [calls, options],\n  );\n\n  const enabled = useMemo(() => Boolean(enabled_ && calls), [enabled_, calls]);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    enabled,\n    queryKey: queryKey_,\n    queryFn: queryFn({\n      account,\n      calls,\n      options,\n    }),\n    ...props,\n  });\n}\n\nfunction queryKey({ calls, options }: EstimateFeesArgs) {\n  return [\n    {\n      entity: \"estimateInvokeFee\",\n      calls,\n      options,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  account,\n  calls,\n  options,\n}: { account?: AccountInterface } & EstimateFeesArgs) {\n  return async function () {\n    if (!account) throw new Error(\"account is required\");\n    if (!calls || calls.length === 0) throw new Error(\"calls are required\");\n    return account?.estimateInvokeFee(calls, options);\n  };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { RpcProvider, RpcProviderOptions } from \"starknet\";\n\nimport { starknetChainId } from \"~/context\";\nimport { ChainProviderFactory } from \"./factory\";\n\n/** Arguments for `jsonRpcProvider`. */\nexport type JsonRpcProviderArgs = {\n  rpc: (chain: Chain) => RpcProviderOptions | null;\n};\n\n/** Configure the JSON-RPC provider using the provided function. */\nexport function jsonRpcProvider({\n  rpc,\n}: JsonRpcProviderArgs): ChainProviderFactory<RpcProvider> {\n  return function (chain) {\n    const config = rpc(chain);\n    if (!config) return null;\n    const chainId = starknetChainId(chain.id);\n\n    const provider = new RpcProvider({ ...config, chainId });\n    return provider;\n  };\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Configure the provider to use the public RPC endpoint. */\nexport function publicProvider() {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      // Pick random node from the list of public nodes.\n      const rpcs = chain.rpcUrls.public.http;\n      const nodeUrl = rpcs[Math.floor(Math.random() * rpcs.length)];\n      if (!nodeUrl) return null;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `alchemyProvider`. */\nexport type AlchemyProviderArgs = {\n  /** Alchemy API key. */\n  apiKey: string;\n};\n\n/** Configure the Alchemy provider using the provided API key. */\nexport function alchemyProvider({ apiKey }: AlchemyProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"alchemy\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `blastProvider`. */\nexport type BlastProviderArgs = {\n  /** Blast API key. */\n  apiKey: string;\n};\n\n/** Configure the Blast provider using the provided API key. */\nexport function blastProvider({ apiKey }: BlastProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"blast\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `infuraProvider`. */\nexport type InfuraProviderArgs = {\n  /** Infura API key. */\n  apiKey: string;\n};\n\n/** Configure the Infura provider using the provided API key. */\nexport function infuraProvider({ apiKey }: InfuraProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"infura\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `lavaProvider`. */\nexport type LavaProviderArgs = {\n  /** Lava API key. */\n  apiKey: string;\n};\n\n/** Configure the Lava provider using the provided API key. */\nexport function lavaProvider({ apiKey }: LavaProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"lava\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `nethermindProvider`. */\nexport type NethermindProviderArgs = {\n  /** Nethermind API key. */\n  apiKey: string;\n};\n\n/** Configure the Nethermind provider using the provided API key. */\nexport function nethermindProvider({ apiKey }: NethermindProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"nethermind\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/?apikey=${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `reddioProvider`. */\nexport type ReddioProviderArgs = {\n  /** Reddio API key. */\n  apiKey: string;\n};\n\n/** Configure the Reddio provider using the provided API key. */\nexport function reddioProvider({ apiKey }: ReddioProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"reddio\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "export class Subscribable<TListener extends Function> {\n  protected listeners = new Set<TListener>()\n\n  constructor() {\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n", "import type {\n  DefaultError,\n  Enabled,\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n  StaleTime,\n  StaleTimeFunction,\n} from './types'\nimport type { Mutation } from './mutation'\nimport type { FetchOptions, Query } from './query'\n\n// TYPES\n\nexport interface QueryFilters<TQueryKey extends QueryKey = QueryKey> {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: TQueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (\n    mutation: Mutation<TData, TError, TVariables, TContext>,\n  ) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function resolveStaleTime<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  staleTime:\n    | undefined\n    | StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): StaleTime | undefined {\n  return typeof staleTime === 'function' ? staleTime(query) : staleTime\n}\n\nexport function resolveEnabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  enabled: undefined | Enabled<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): boolean | undefined {\n  return typeof enabled === 'function' ? enabled(query) : enabled\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aItems = array ? a : Object.keys(a)\n    const aSize = aItems.length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n    const aItemsSet = new Set(aItems)\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      if (\n        ((!array && aItemsSet.has(key)) || array) &&\n        a[key] === undefined &&\n        b[key] === undefined\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key])\n        if (copy[key] === a[key] && a[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Handles Objects created by Object.create(<arbitrary prototype>)\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== 'production') {\n      try {\n        return replaceEqualDeep(prevData, data)\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,\n        )\n\n        // Prevent the replaceEqualDeep from being called again down below.\n        throw error\n      }\n    }\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n\nexport function ensureQueryFn<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: {\n    queryFn?: QueryFunction<TQueryFnData, TQueryKey> | SkipToken\n    queryHash?: string\n  },\n  fetchOptions?: FetchOptions<TQueryFnData>,\n): QueryFunction<TQueryFnData, TQueryKey> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,\n      )\n    }\n  }\n\n  // if we attempt to retry a fetch that was triggered from an initialPromise\n  // when we don't have a queryFn yet, we can't retry, so we just return the already rejected initialPromise\n  // if an observer has already mounted, we will be able to retry with that queryFn\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise!\n  }\n\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () =>\n      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`))\n  }\n\n  return options.queryFn\n}\n\nexport function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwOnError function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (focused: boolean) => void\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable<Listener> {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    const isFocused = this.isFocused()\n    this.listeners.forEach((listener) => {\n      listener(isFocused)\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n", "/**\n * Thenable types which matches React's types for promises\n *\n * React seemingly uses `.status`, `.value` and `.reason` properties on a promises to optimistically unwrap data from promises\n *\n * @see https://github.com/facebook/react/blob/main/packages/shared/ReactTypes.js#L112-L138\n * @see https://github.com/facebook/react/blob/4f604941569d2e8947ce1460a0b2997e835f37b9/packages/react-debug-tools/src/ReactDebugHooks.js#L224-L227\n */\n\nimport { noop } from './utils'\n\ninterface Fulfilled<T> {\n  status: 'fulfilled'\n  value: T\n}\ninterface Rejected {\n  status: 'rejected'\n  reason: unknown\n}\ninterface Pending<T> {\n  status: 'pending'\n\n  /**\n   * Resolve the promise with a value.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  resolve: (value: T) => void\n  /**\n   * Reject the promise with a reason.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  reject: (reason: unknown) => void\n}\n\nexport type FulfilledThenable<T> = Promise<T> & Fulfilled<T>\nexport type RejectedThenable<T> = Promise<T> & Rejected\nexport type PendingThenable<T> = Promise<T> & Pending<T>\n\nexport type Thenable<T> =\n  | FulfilledThenable<T>\n  | RejectedThenable<T>\n  | PendingThenable<T>\n\nexport function pendingThenable<T>(): PendingThenable<T> {\n  let resolve: Pending<T>['resolve']\n  let reject: Pending<T>['reject']\n  // this could use `Promise.withResolvers()` in the future\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  }) as PendingThenable<T>\n\n  thenable.status = 'pending'\n  thenable.catch(() => {\n    // prevent unhandled rejection errors\n  })\n\n  function finalize(data: Fulfilled<T> | Rejected) {\n    Object.assign(thenable, data)\n\n    // clear pending props props to avoid calling them twice\n    delete (thenable as Partial<PendingThenable<T>>).resolve\n    delete (thenable as Partial<PendingThenable<T>>).reject\n  }\n\n  thenable.resolve = (value) => {\n    finalize({\n      status: 'fulfilled',\n      value,\n    })\n\n    resolve(value)\n  }\n  thenable.reject = (reason) => {\n    finalize({\n      status: 'rejected',\n      reason,\n    })\n\n    reject(reason)\n  }\n\n  return thenable\n}\n\n/**\n * This function takes a Promise-like input and detects whether the data\n * is synchronously available or not.\n *\n * It does not inspect .status, .value or .reason properties of the promise,\n * as those are not always available, and the .status of React's promises\n * should not be considered part of the public API.\n */\nexport function tryResolveSync(promise: Promise<unknown> | Thenable<unknown>) {\n  let data: unknown\n\n  promise\n    .then((result) => {\n      data = result\n      return result\n    }, noop)\n    // .catch can be unavailable on certain kinds of thenable's\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    ?.catch(noop)\n\n  if (data !== undefined) {\n    return { data }\n  }\n\n  return undefined\n}\n", "import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n", "// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport const defaultScheduler: ScheduleFunction = (cb) => setTimeout(cb, 0)\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn = defaultScheduler\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  return {\n    batch: <T>(callback: () => T): T => {\n      let result\n      transactions++\n      try {\n        result = callback()\n      } finally {\n        transactions--\n        if (!transactions) {\n          flush()\n        }\n      }\n      return result\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: <T extends Array<unknown>>(\n      callback: BatchCallsCallback<T>,\n    ): BatchCallsCallback<T> => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args)\n        })\n      }\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn: NotifyFunction) => {\n      notifyFn = fn\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {\n      batchNotifyFn = fn\n    },\n    setScheduler: (fn: ScheduleFunction) => {\n      scheduleFn = fn\n    },\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n", "import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n", "import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n", "import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n", "import { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { createRetryer } from './retryer'\nimport type {\n  DefaultError,\n  MutationMeta,\n  MutationOptions,\n  MutationStatus,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TContext> {\n  type: 'pending'\n  isPaused: boolean\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TContext>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  readonly mutationId: number\n\n  #observers: Array<MutationObserver<TData, TError, TVariables, TContext>>\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.mutationId = config.mutationId\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = options\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    const onContinue = () => {\n      this.#dispatch({ type: 'continue' })\n    }\n\n    this.#retryer = createRetryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error('No mutationFn found'))\n        }\n        return this.options.mutationFn(variables)\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue,\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this),\n    })\n\n    const restored = this.state.status === 'pending'\n    const isPaused = !this.#retryer.canStart()\n\n    try {\n      if (restored) {\n        // Dispatch continue action to unpause restored mutation\n        onContinue()\n      } else {\n        this.#dispatch({ type: 'pending', variables, isPaused })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(variables)\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n            isPaused,\n          })\n        }\n      }\n      const data = await this.#retryer.start()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(data, variables, this.state.context!)\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(data, null, variables, this.state.context)\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    } finally {\n      this.#mutationCache.runNext(this)\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n", "import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n", "import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n", "import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<TQueryFilters extends QueryFilters<any> = QueryFilters>(\n    filters?: TQueryFilters,\n  ): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get<TInferredQueryFnData>(options.queryHash)?.state\n      .data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(filters: TQueryFilters): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): NoInfer<TInferredQueryFnData> | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TQueryFnData> | undefined,\n      NoInfer<TQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled() && !query.isStatic())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TContext = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n", "import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error('experimental_prefetchInRender feature flag is not enabled'),\n      )\n    }\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n", "import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n", "/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n", "'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'subscribed'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries:\n      | readonly [...QueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> }]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n    subscribed?: boolean\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop,\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n          suspense: query.suspense,\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n", "'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n", "'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n", "import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static' ? value : Math.max(value ?? 1000, 1000)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n", "'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n", "'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  NoInfer,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n", "'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it must\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  const hydrationQueue: DehydratedState['queries'] | undefined =\n    React.useMemo(() => {\n      if (state) {\n        if (typeof state !== 'object') {\n          return\n        }\n\n        const queryCache = client.getQueryCache()\n        // State is supplied from the outside and we might as well fail\n        // gracefully if it has the wrong shape, so while we type `queries`\n        // as required, we still provide a fallback.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const queries = (state as DehydratedState).queries || []\n\n        const newQueries: DehydratedState['queries'] = []\n        const existingQueries: DehydratedState['queries'] = []\n        for (const dehydratedQuery of queries) {\n          const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery)\n          } else {\n            const hydrationIsNewer =\n              dehydratedQuery.state.dataUpdatedAt >\n                existingQuery.state.dataUpdatedAt ||\n              (dehydratedQuery.promise &&\n                existingQuery.state.status !== 'pending' &&\n                existingQuery.state.fetchStatus !== 'fetching' &&\n                dehydratedQuery.dehydratedAt !== undefined &&\n                dehydratedQuery.dehydratedAt >\n                  existingQuery.state.dataUpdatedAt)\n\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery)\n            }\n          }\n        }\n\n        if (newQueries.length > 0) {\n          // It's actually fine to call this with queries/state that already exists\n          // in the cache, or is older. hydrate() is idempotent for queries.\n          hydrate(client, { queries: newQueries }, optionsRef.current)\n        }\n        if (existingQueries.length > 0) {\n          return existingQueries\n        }\n      }\n      return undefined\n    }, [client, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n", "'use client'\nimport * as React from 'react'\nimport { notifyManager } from '@tanstack/query-core'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport type { QueryClient, QueryFilters } from '@tanstack/query-core'\n\nexport function useIsFetching(\n  filters?: QueryFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  const queryCache = client.getQueryCache()\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters),\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nimport { notifyManager, replaceEqualDeep } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  return useMutationState(\n    { filters: { ...filters, status: 'pending' } },\n    client,\n  ).length\n}\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (mutation: Mutation) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select ? options.select(mutation) : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): Array<TResult> {\n  const mutationCache = useQueryClient(queryClient).getMutationCache()\n  const optionsRef = React.useRef(options)\n  const result = React.useRef<Array<TResult>>(null)\n  if (!result.current) {\n    result.current = getResult(mutationCache, options)\n  }\n\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(() => {\n          const nextResult = replaceEqualDeep(\n            result.current,\n            getResult(mutationCache, optionsRef.current),\n          )\n          if (result.current !== nextResult) {\n            result.current = nextResult\n            notifyManager.schedule(onStoreChange)\n          }\n        }),\n      [mutationCache],\n    ),\n    () => result.current,\n    () => result.current,\n  )!\n}\n", "'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n", "export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n", "export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n", "import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n", "import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n", "import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n", "import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n", "export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n", "import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n"],
  "mappings": "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",
  "names": ["EventEmitter", "EventEmitter", "queryKey", "mutationKey", "_a", "_a", "_cleanup", "_setup", "_a", "_a", "_a", "queryFn", "queryFnContext", "context", "_b", "_c", "_a", "queryKey", "_a", "_dispatch", "_retryer", "getDefaultState", "dispatch_fn", "_a", "_a", "queryFn", "queryFnContext", "_b", "_a", "_mutationCache", "_defaultOptions", "queryKey", "mutationKey", "_a", "_client", "_a", "_notify", "_client", "_currentResult", "notify_fn", "getDefaultState", "React", "React", "React", "import_jsx_runtime", "React", "React", "_a", "React", "React", "React", "React", "import_react", "import_react", "import_jsx_runtime", "import_react", "import_react", "util", "objectUtil", "errorUtil", "errorMap", "_a", "ctx", "result", "issues", "elements", "processed", "result", "r", "ZodFirstPartyTypeKind", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "_a", "accounts", "connectors", "injected", "isWalletObject", "goerli", "mainnet", "React", "useContext", "useState", "useCallback", "state", "account", "useEffect", "jsx", "sepolia", "hash", "useQuery", "useMutation", "useMemo", "queryKey", "BlockTag", "queryFn", "DEFAULT_FETCH_INTERVAL", "mutationKey", "mutationFn", "CallData", "StarknetIdNamingContract", "Provider", "starknetId", "shortString"]
}
